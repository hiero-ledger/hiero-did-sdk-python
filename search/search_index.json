{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hiero DID SDK Python","text":"<p>This repository contains the Python SDK that enables developers to manage Decentralized Identifiers (DIDs) and AnonCreds Verifiable Credentials on the Hedera network using the Hedera Consensus Service.</p> <p>This library is using Hiero Python SDK.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>At the moment, SDK comes with following configuration capabilities:</p> <ul> <li>Hedera Client configuration</li> <li>Cache implementation (optional)</li> <li>Logger configuration (optional)</li> </ul>"},{"location":"configuration/#hedera-client-configuration","title":"Hedera Client configuration","text":"<p>Configuration consists from two parts:</p> <ul> <li>Network configuration</li> <li>Basic configuration is lightweight and consists from selection of specific network (\"mainnet\", \"testnet\", \"     previewnet\"), complex parts are handled by Hedera Python SDK</li> <li>Custom configuration can be provided, if necessary</li> <li>Hedera operator (account) configuration</li> <li>Essentially, account \"credentials\" that will be used for Hedera network integration and paying fees</li> <li>Needs to be provided explicitly and can be changed for specific Hedera Client instance via provider class</li> </ul>"},{"location":"configuration/#examples","title":"Examples","text":""},{"location":"configuration/#create-client-for-testnet-and-set-operator-config","title":"Create client for Testnet and set operator config","text":"<pre><code>from hiero_sdk_python import Client, Network, AccountId, PrivateKey\n\nclient = Client(\n    network=Network(\"testnet\")\n)\n\nclient.set_operator(AccountId.from_string(\"OPERATOR_ID\"), private_key=PrivateKey.from_string(\"OPERATOR_KEY\"))\n</code></pre>"},{"location":"configuration/#create-client-provider-with-custom-network-config","title":"Create client provider with custom network config","text":"<pre><code>from hiero_sdk_python import Client, Network, AccountId, PrivateKey\n\nTESTNET_NODES = [\n    (\"0.testnet.hedera.com:50211\", AccountId(0, 0, 3)),\n    (\"1.testnet.hedera.com:50211\", AccountId(0, 0, 4))\n]\n\nclient = Client(\n    network=Network(network=\"testnet\", nodes=TESTNET_NODES, mirror_address=\"hcs.testnet.mirrornode.hedera.com:5600\"),\n)\nclient.set_operator(AccountId.from_string(\"OPERATOR_ID\"), private_key=PrivateKey.from_string(\"OPERATOR_KEY\"))\n</code></pre>"},{"location":"configuration/#cache-implementation","title":"Cache implementation","text":"<p>SDK utilizes cache to optimize read operations and provides an option to customize cache implementation (individually for each resolver instance).</p> <p>By default, in-memory cache implementation is used.</p> <p>You can create custom cache implementation by inheriting Cache base class. Custom cache instance needs to be provided in resolver constructor arguments.</p> <p>Classes that accept custom cache implementation:</p> <ul> <li>HederaDidResolver</li> <li>HederaAnonCredsRegistry</li> </ul>"},{"location":"configuration/#example","title":"Example","text":"<pre><code>from hiero_did_sdk_python import Cache, HederaDidResolver\n\nclass CustomCache(Cache):\n  ...\n\ncustom_cache_instance = CustomCache[str, object]()\n\nresolver = HederaDidResolver(client, custom_cache_instance)\n</code></pre>"},{"location":"configuration/#logger-configuration","title":"Logger configuration","text":"<p>Logger configuration supports following properties that can be set with environment variables:</p> <ul> <li>Log level</li> <li>Env variable name: <code>HEDERA_DID_SDK_LOG_LEVEL</code></li> <li>Currently supported values: \"DEBUG\", \"INFO\", \"WARN\", \"ERROR\"</li> <li>Log format (in string representation)</li> <li>Env variable name: <code>HEDERA_DID_SDK_LOG_FORMAT</code></li> <li>For uniformity purposes, the SDK expects format string to correspond with Java (     <code>ch.qos.logback:logback-classic</code>) pattern</li> </ul>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12+</li> <li>Poetry (at least 1.8.4)</li> <li>NodeJS and npm (used by pre-commit hooks)</li> <li>Tools for Makefile support (Windows only)</li> <li>Can be installed with chocolatey: <code>choco install make</code></li> </ul>"},{"location":"getting-started/#install-package","title":"Install package","text":"<pre><code>pip install hiero-did-sdk-python\n</code></pre>"},{"location":"getting-started/#example-usage","title":"Example usage","text":"<p>Here you can find basic SDK usage examples.</p> <p>For more complex examples, please refer to SDK integration tests:</p> <ul> <li>Hedera DID</li> <li>AnonCreds registry</li> </ul>"},{"location":"getting-started/#create-hedera-client-for-testnet","title":"Create Hedera Client (for testnet)","text":"<pre><code>from hiero_sdk_python import Client, Network, AccountId, PrivateKey\n\nclient = Client(\n    network=Network(\"testnet\")\n)\n\nclient.set_operator(AccountId.from_string(\"OPERATOR_ID\"), private_key=PrivateKey.from_string(\"OPERATOR_KEY\"))\n</code></pre>"},{"location":"getting-started/#register-new-hedera-did-on-testnet-network-and-add-did-service","title":"Register new Hedera DID on testnet network and add DID service","text":"<pre><code>from hiero_did_sdk_python import HederaDid\n\ndid = HederaDid(client=client, private_key_der=\"private_key_der\")\n\nawait did.register()\n\nawait did.add_or_update_service(\n    id_=f\"{did.identifier}#service-1\", service_type=\"LinkedDomains\", service_endpoint=\"https://example.com/vcs\"\n)\n</code></pre>"},{"location":"getting-started/#resolve-existing-hedera-did","title":"Resolve existing Hedera DID","text":"<pre><code>from hiero_did_sdk_python import HederaDidResolver\n\nresolver = HederaDidResolver(client)\n\nresolution_result = await resolver.resolve(\n    \"did:hedera:testnet:zvAQyPeUecGck2EsxcsihxhAB6jZurFrBbj2gC7CNkS5o_0.0.5063027\")\n</code></pre>"},{"location":"getting-started/#create-anoncreds-credential-schema-and-credential-definition","title":"Create AnonCreds credential schema and credential definition","text":"<pre><code>from hiero_did_sdk_python import HederaAnonCredsRegistry, AnonCredsSchema, AnonCredsCredDef, CredDefValue, CredDefValuePrimary\n\nissuer_did = \"did:hedera:testnet:zvAQyPeUecGck2EsxcsihxhAB6jZurFrBbj2gC7CNkS5o_0.0.5063027\"\nregistry = HederaAnonCredsRegistry(client)\n\nschema = AnonCredsSchema(\n    name=\"schema-name\",\n    issuer_id=issuer_did,\n    attr_names=[\"name\", \"age\"],\n    version=\"1\"\n)\n\nschema_registration_result = await registry.register_schema(schema, issuer_did, \"OPERATOR_KEY_DER\")\n\ncred_def = AnonCredsCredDef(\n    schema_id=schema_registration_result.schema_state.schema_id,\n    issuer_id=issuer_did,\n    value=CredDefValue(primary=CredDefValuePrimary(...)),\n    tag=\"cred-def-tag\"\n)\n\ncred_def_registration_result = await registry.register_cred_def(cred_def, issuer_did, \"OPERATOR_KEY_DER\")\n</code></pre>"},{"location":"modules/anoncreds/","title":"AnonCreds module","text":"<p>This module provides Hedera AnonCreds Registry API.</p> <p>Please note that only AnonCreds Verifiable Data Registry (VDR) capabilities are provided by SDK, so it's intended to be used along with actual AnonCreds implementations (such as anoncreds-rs Python wrapper).</p>"},{"location":"modules/anoncreds/#anoncreds-registry","title":"AnonCreds Registry","text":""},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.hedera_anoncreds_registry.HederaAnonCredsRegistry","title":"<code>HederaAnonCredsRegistry</code>","text":"<p>Anoncreds objects registry (resolver + registrar) implementation that leverage Hedera HCS as VDR.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>Hedera Client</p> required <code>cache_instance</code> <code>Cache[str, object] | None</code> <p>Custom cache instance. If not provided, in-memory cache is used</p> <code>None</code> Source code in <code>hiero_did_sdk_python/anoncreds/hedera_anoncreds_registry.py</code> <pre><code>class HederaAnonCredsRegistry:\n    \"\"\"Anoncreds objects registry (resolver + registrar) implementation that leverage Hedera HCS as VDR.\n\n    Args:\n        client: Hedera Client\n        cache_instance: Custom cache instance. If not provided, in-memory cache is used\n    \"\"\"\n\n    def __init__(\n        self,\n        client: Client,\n        cache_instance: Cache[str, object] | None = None,\n    ):\n        self._client = client\n        self._hcs_file_service = HcsFileService(client)\n        self._hcs_topic_service = HcsTopicService(client)\n\n        cache_instance = cache_instance or MemoryCache[str, object]()\n\n        self._schema_cache: Cache[str, AnonCredsSchema] = cast(Cache[str, AnonCredsSchema], cache_instance)\n        self._cred_def_cache: Cache[str, AnonCredsCredDef] = cast(Cache[str, AnonCredsCredDef], cache_instance)\n        self._rev_reg_def_cache: Cache[str, RevRegDefWithHcsMetadata] = cast(\n            Cache[str, RevRegDefWithHcsMetadata], cache_instance\n        )\n        self._rev_reg_entries_messages_cache = cast(Cache[str, list[HcsMessageWithResponseMetadata]], cache_instance)\n\n    async def get_schema(self, schema_id: str) -&gt; GetSchemaResult:\n        \"\"\"Get a schema from the registry.\n\n        Args:\n            schema_id: Schema ID to resolver\n\n        Returns:\n            object: Schema resolution result\n        \"\"\"\n        try:\n            parsed_identifier = parse_anoncreds_identifier(schema_id)\n\n            if parsed_identifier.object_type != AnonCredsObjectType.SCHEMA:\n                return GetSchemaResult(\n                    schema_id=schema_id,\n                    resolution_metadata={\n                        \"error\": \"notFound\",\n                        \"message\": f\"AnonCreds Schema id '{schema_id}' is invalid\",\n                    },\n                    schema_metadata={},\n                )\n\n            schema_topic_id = parsed_identifier.topic_id\n\n            cached_schema = self._schema_cache.get(schema_topic_id)\n\n            if cached_schema:\n                schema = cached_schema\n            else:\n                schema_payload = await self._hcs_file_service.resolve_file(parsed_identifier.topic_id)\n                schema = AnonCredsSchema.from_json(schema_payload.decode()) if schema_payload else None\n\n                if not schema:\n                    return GetSchemaResult(\n                        schema_id=schema_id,\n                        resolution_metadata={\n                            \"error\": \"notFound\",\n                            \"message\": f\"AnonCreds schema with id '{schema_id}' not found\",\n                        },\n                        schema_metadata={},\n                    )\n\n                self._schema_cache.set(schema_topic_id, schema)\n\n            return GetSchemaResult(schema=schema, schema_id=schema_id, resolution_metadata={}, schema_metadata={})\n        except Exception as error:\n            LOGGER.error(f\"Error on retrieving AnonCreds Schema: {error!s}\")\n            return GetSchemaResult(\n                schema_id=schema_id,\n                resolution_metadata={\n                    \"error\": \"otherError\",\n                    \"message\": f\"unable to resolve schema: ${error!s}\",\n                },\n                schema_metadata={},\n            )\n\n    async def register_schema(self, schema: AnonCredsSchema, issuer_key_der: str) -&gt; RegisterSchemaResult:\n        \"\"\"Register Schema.\n\n        Args:\n            schema: Schema object to register\n            issuer_key_der: Issuer private key encoded in DER format\n\n        Returns:\n            object: Schema registration result\n        \"\"\"\n        try:\n            hcs_file_payload = schema.to_json().encode()\n            schema_topic_id = await self._hcs_file_service.submit_file(hcs_file_payload, issuer_key_der)\n\n            return RegisterSchemaResult(\n                schema_state=SchemaState(\n                    state=\"finished\",\n                    schema=schema,\n                    schema_id=build_anoncreds_identifier(schema.issuer_id, schema_topic_id, AnonCredsObjectType.SCHEMA),\n                ),\n                schema_metadata={},\n                registration_metadata={},\n            )\n        except Exception as error:\n            LOGGER.error(f\"Error on registering Anoncreds Schema: {error!s}\")\n            return RegisterSchemaResult(\n                schema_state=SchemaState(state=\"failed\", schema=schema, reason=f\"unknownError: ${error!s}\"),\n                schema_metadata={},\n                registration_metadata={},\n            )\n\n    async def get_cred_def(self, cred_def_id: str) -&gt; GetCredDefResult:\n        \"\"\"Get a credential definition from the registry.\n\n        Args:\n            cred_def_id: Credential definition ID to resolve\n\n        Returns:\n            object: Credential definition resolution result\n        \"\"\"\n        try:\n            parsed_identifier = parse_anoncreds_identifier(cred_def_id)\n\n            if parsed_identifier.object_type != AnonCredsObjectType.PUBLIC_CRED_DEF:\n                return GetCredDefResult(\n                    credential_definition_id=cred_def_id,\n                    resolution_metadata={\n                        \"error\": \"notFound\",\n                        \"message\": f\"Credential definition id '{cred_def_id}' is invalid\",\n                    },\n                    credential_definition_metadata={},\n                )\n\n            cred_def_topic_id = parsed_identifier.topic_id\n\n            cached_cred_def = self._cred_def_cache.get(cred_def_topic_id)\n\n            if cached_cred_def:\n                cred_def = cached_cred_def\n            else:\n                cred_def_payload = await self._hcs_file_service.resolve_file(cred_def_topic_id)\n                cred_def = AnonCredsCredDef.from_json(cred_def_payload.decode()) if cred_def_payload else None\n\n                if not cred_def:\n                    return GetCredDefResult(\n                        credential_definition_id=cred_def_id,\n                        resolution_metadata={\n                            \"error\": \"notFound\",\n                            \"message\": f\"AnonCreds credential definition with id '{cred_def_id}' not found\",\n                        },\n                        credential_definition_metadata={},\n                    )\n\n                self._cred_def_cache.set(cred_def_topic_id, cred_def)\n\n            return GetCredDefResult(\n                credential_definition=cred_def,\n                credential_definition_id=cred_def_id,\n                resolution_metadata={},\n                credential_definition_metadata={},\n            )\n        except Exception as error:\n            LOGGER.error(f\"Error on retrieving AnonCreds credential definition: {error!s}\")\n            return GetCredDefResult(\n                credential_definition_id=cred_def_id,\n                resolution_metadata={\n                    \"error\": \"otherError\",\n                    \"message\": f\"unable to resolve credential definition: ${error!s}\",\n                },\n                credential_definition_metadata={},\n            )\n\n    async def register_cred_def(self, cred_def: AnonCredsCredDef, issuer_key_der: str) -&gt; RegisterCredDefResult:\n        \"\"\"Register Credential Definition.\n\n        Args:\n            cred_def: Credential definition object to register\n            issuer_key_der: Issuer private key encoded in DER\n\n        Returns:\n            object: Credential definition registration result\n        \"\"\"\n        try:\n            hcs_file_payload = cred_def.to_json().encode()\n            cred_def_topic_id = await self._hcs_file_service.submit_file(hcs_file_payload, issuer_key_der)\n\n            return RegisterCredDefResult(\n                credential_definition_state=CredDefState(\n                    state=\"finished\",\n                    credential_definition=cred_def,\n                    credential_definition_id=build_anoncreds_identifier(\n                        cred_def.issuer_id, cred_def_topic_id, AnonCredsObjectType.PUBLIC_CRED_DEF\n                    ),\n                ),\n                registration_metadata={},\n                credential_definition_metadata={},\n            )\n        except Exception as error:\n            LOGGER.error(f\"Error on registering Anoncreds Cred Def: {error!s}\")\n            return RegisterCredDefResult(\n                credential_definition_state=CredDefState(\n                    state=\"failed\", credential_definition=cred_def, reason=f\"unknownError: ${error!s}\"\n                ),\n                registration_metadata={},\n                credential_definition_metadata={},\n            )\n\n    async def get_rev_reg_def(self, revocation_registry_definition_id: str) -&gt; GetRevRegDefResult:\n        \"\"\"Get a revocation registry definition from the registry.\n\n        Args:\n            revocation_registry_definition_id: Revocation registry definition ID to resolve\n\n        Returns:\n            object: Revocation registry definition resolution result\n        \"\"\"\n        try:\n            parsed_identifier = parse_anoncreds_identifier(revocation_registry_definition_id)\n\n            if parsed_identifier.object_type != AnonCredsObjectType.REV_REG:\n                return GetRevRegDefResult(\n                    revocation_registry_definition_id=revocation_registry_definition_id,\n                    resolution_metadata={\n                        \"error\": \"notFound\",\n                        \"message\": f\"Revocation registry id '{revocation_registry_definition_id}' is invalid\",\n                    },\n                    revocation_registry_definition_metadata={},\n                )\n\n            rev_reg_def_topic_id = parsed_identifier.topic_id\n\n            cached_rev_reg_def_with_metadata = self._rev_reg_def_cache.get(rev_reg_def_topic_id)\n\n            if cached_rev_reg_def_with_metadata:\n                rev_reg_def_with_metadata = cached_rev_reg_def_with_metadata\n            else:\n                rev_reg_def_payload = await self._hcs_file_service.resolve_file(rev_reg_def_topic_id)\n                rev_reg_def_with_metadata = (\n                    RevRegDefWithHcsMetadata.from_json(rev_reg_def_payload.decode()) if rev_reg_def_payload else None\n                )\n\n                if not rev_reg_def_with_metadata:\n                    return GetRevRegDefResult(\n                        revocation_registry_definition_id=revocation_registry_definition_id,\n                        resolution_metadata={\n                            \"error\": \"notFound\",\n                            \"message\": f\"AnonCreds revocation registry with id '{revocation_registry_definition_id}' not found\",\n                        },\n                        revocation_registry_definition_metadata={},\n                    )\n\n                self._rev_reg_def_cache.set(rev_reg_def_topic_id, rev_reg_def_with_metadata)\n\n            return GetRevRegDefResult(\n                revocation_registry_definition=rev_reg_def_with_metadata.rev_reg_def,\n                revocation_registry_definition_id=revocation_registry_definition_id,\n                resolution_metadata={},\n                revocation_registry_definition_metadata={**rev_reg_def_with_metadata.hcs_metadata},\n            )\n        except Exception as error:\n            LOGGER.error(f\"Error on retrieving AnonCreds revocation registry definition: {error!s}\")\n            return GetRevRegDefResult(\n                revocation_registry_definition_id=revocation_registry_definition_id,\n                resolution_metadata={\n                    \"error\": \"otherError\",\n                    \"message\": f\"unable to resolve revocation registry definition: ${error!s}\",\n                },\n                revocation_registry_definition_metadata={},\n            )\n\n    async def register_rev_reg_def(\n        self, rev_reg_def: AnonCredsRevRegDef, issuer_key_der: str\n    ) -&gt; RegisterRevRegDefResult:\n        \"\"\"Register Revocation registry definition.\n\n        Args:\n            rev_reg_def: Revocation registry definition object to register\n            issuer_key_der: Issuer private key encoded in DER\n\n        Returns:\n            object: Revocation registry definition registration result\n        \"\"\"\n        try:\n            issuer_key = PrivateKey.from_string(issuer_key_der)\n\n            entries_topic_options = HcsTopicOptions(submit_key=issuer_key.public_key())\n            entries_topic_id = await self._hcs_topic_service.create_topic(entries_topic_options, [issuer_key])\n\n            rev_reg_def_with_metadata = RevRegDefWithHcsMetadata(\n                rev_reg_def=rev_reg_def, hcs_metadata={\"entriesTopicId\": entries_topic_id}\n            )\n\n            hcs_file_payload = rev_reg_def_with_metadata.to_json().encode()\n            rev_reg_def_topic_id = await self._hcs_file_service.submit_file(hcs_file_payload, issuer_key_der)\n\n            # We want to cache registry definition right away\n            # Helps to avoid potential cases where issuer pushes rev entries immediately but registry definition data (HCS-1 messages) is not propagated to mirror nodes yet\n            self._rev_reg_def_cache.set(rev_reg_def_topic_id, rev_reg_def_with_metadata)\n\n            return RegisterRevRegDefResult(\n                revocation_registry_definition_state=RevRegDefState(\n                    state=\"finished\",\n                    revocation_registry_definition=rev_reg_def,\n                    revocation_registry_definition_id=build_anoncreds_identifier(\n                        rev_reg_def.issuer_id, rev_reg_def_topic_id, AnonCredsObjectType.REV_REG\n                    ),\n                ),\n                registration_metadata={},\n                revocation_registry_definition_metadata={**rev_reg_def_with_metadata.hcs_metadata},\n            )\n        except Exception as error:\n            LOGGER.error(f\"Error on registering Anoncreds Revocation registry definition: {error!s}\")\n            return RegisterRevRegDefResult(\n                revocation_registry_definition_state=RevRegDefState(\n                    state=\"failed\", revocation_registry_definition=rev_reg_def, reason=f\"unknownError: ${error!s}\"\n                ),\n                registration_metadata={},\n                revocation_registry_definition_metadata={},\n            )\n\n    async def get_rev_list(self, rev_reg_id: str, timestamp: int) -&gt; GetRevListResult:\n        \"\"\"Get a revocation list from the registry.\n\n        Args:\n            rev_reg_id: Revocation registry ID\n            timestamp: Timestamp to resolve revocation list for\n\n        Returns:\n            object: Revocation list resolution result\n        \"\"\"\n        try:\n            rev_reg_def_result = await self.get_rev_reg_def(rev_reg_id)\n\n            if not rev_reg_def_result.revocation_registry_definition:\n                return GetRevListResult(\n                    revocation_registry_id=rev_reg_id,\n                    resolution_metadata={\n                        \"error\": \"notFound\",\n                        \"message\": f\"AnonCreds revocation registry with id '{rev_reg_id}' not found\",\n                    },\n                    revocation_list_metadata={},\n                )\n\n            rev_reg_def = rev_reg_def_result.revocation_registry_definition\n            entries_topic_id = rev_reg_def_result.revocation_registry_definition_metadata.get(\"entriesTopicId\")\n\n            if not entries_topic_id:\n                return GetRevListResult(\n                    revocation_registry_id=rev_reg_id,\n                    resolution_metadata={\n                        \"error\": \"notFound\",\n                        \"message\": \"Entries topic ID is missing from revocation registry metadata\",\n                    },\n                    revocation_list_metadata={},\n                )\n\n            cached_messages = self._rev_reg_entries_messages_cache.get(entries_topic_id)\n            if cached_messages:\n                last_cached_message_timestamp = cached_messages[-1].consensus_timestamp\n\n                if last_cached_message_timestamp.seconds &gt;= timestamp:\n                    borderline_timestamp = Timestamp(seconds=timestamp, nanos=0)\n                    entries_messages = filter(\n                        lambda message: message.consensus_timestamp.seconds &lt; timestamp\n                        or message.consensus_timestamp == borderline_timestamp,\n                        cached_messages,\n                    )\n                    entries = [cast(AnonCredsRevRegEntry, message.message) for message in entries_messages]\n\n                    # This means that requested timestamp is before the actual registration of rev list\n                    # In such case, we want to return initial state for the list (by adding first message to entries)\n                    if len(entries) == 0:\n                        entries.append(cast(AnonCredsRevRegEntry, cached_messages[0].message))\n\n                    return GetRevListResult(\n                        revocation_registry_id=rev_reg_id,\n                        revocation_list=AnonCredsRevList.from_rev_reg_entries(\n                            entries, rev_reg_id, rev_reg_def, timestamp\n                        ),\n                        resolution_metadata={},\n                        revocation_list_metadata={},\n                    )\n                else:\n                    new_messages = await HcsMessageResolver(\n                        topic_id=entries_topic_id,\n                        message_type=HcsRevRegEntryMessage,\n                        timestamp_from=last_cached_message_timestamp,\n                        timestamp_to=Timestamp(seconds=timestamp, nanos=0),\n                        include_response_metadata=True,\n                    ).execute(self._client)\n\n                    # Note: 'chain' function is used instead of lists sum due to significantly better performance on large lists\n                    # See: https://docs.python.org/3/library/itertools.html, https://stackoverflow.com/a/41772165\n                    entries_messages = (\n                        list(chain(cached_messages, cast(list[HcsMessageWithResponseMetadata], new_messages)))\n                        if len(new_messages) &gt; 0\n                        else cached_messages\n                    )\n\n                    self._rev_reg_entries_messages_cache.set(entries_topic_id, entries_messages)\n\n                    entries = [cast(AnonCredsRevRegEntry, message.message) for message in entries_messages]\n\n                    return GetRevListResult(\n                        revocation_registry_id=rev_reg_id,\n                        revocation_list=AnonCredsRevList.from_rev_reg_entries(\n                            entries, rev_reg_id, rev_reg_def, timestamp\n                        ),\n                        resolution_metadata={},\n                        revocation_list_metadata={},\n                    )\n\n            entries_messages = await HcsMessageResolver(\n                topic_id=entries_topic_id,\n                message_type=HcsRevRegEntryMessage,\n                timestamp_to=Timestamp(seconds=timestamp, nanos=0),\n                include_response_metadata=True,\n            ).execute(self._client)\n\n            if len(entries_messages) == 0:\n                # If returned entries list is empty, we need to fetch the first message and check if list is registered\n                # It's possible that requested timestamp is before the actual registration of rev list -&gt; we want to return initial state for the list (by adding first message to entries)\n\n                # The second request looks redundant here, but it should be the rare case that will be subsequently handled by cache\n                entries_messages = await HcsMessageResolver(\n                    topic_id=entries_topic_id,\n                    message_type=HcsRevRegEntryMessage,\n                    limit=1,\n                    include_response_metadata=True,\n                ).execute(self._client)\n\n                if len(entries_messages) == 0:\n                    return GetRevListResult(\n                        revocation_registry_id=rev_reg_id,\n                        resolution_metadata={\n                            \"error\": \"notFound\",\n                            \"message\": f\"Registered revocation list for registry id '{rev_reg_id}' is not found\",\n                        },\n                        revocation_list_metadata={},\n                    )\n\n            entries_messages = cast(list[HcsMessageWithResponseMetadata], entries_messages)\n            self._rev_reg_entries_messages_cache.set(entries_topic_id, entries_messages)\n\n            entries = [cast(AnonCredsRevRegEntry, message.message) for message in entries_messages]\n\n            return GetRevListResult(\n                revocation_registry_id=rev_reg_id,\n                revocation_list=AnonCredsRevList.from_rev_reg_entries(entries, rev_reg_id, rev_reg_def, timestamp),\n                resolution_metadata={},\n                revocation_list_metadata={},\n            )\n\n        except Exception as error:\n            LOGGER.error(f\"Error on retrieving AnonCreds revocation list: {error!s}\")\n            return GetRevListResult(\n                revocation_registry_id=rev_reg_id,\n                resolution_metadata={\n                    \"error\": \"otherError\",\n                    \"message\": f\"Unable to resolve revocation list: ${error!s}\",\n                },\n                revocation_list_metadata={},\n            )\n\n    async def register_rev_list(self, rev_list: AnonCredsRevList, issuer_key_der: str) -&gt; RegisterRevListResult:\n        \"\"\"Register Revocation list.\n\n        Args:\n            rev_list: Revocation list object to register\n            issuer_key_der: Issuer private key encoded in DER\n\n        Returns: Revocation list registration result\n        \"\"\"\n        try:\n            return await self._submit_rev_list_entry(rev_list, issuer_key_der)\n        except Exception as error:\n            LOGGER.error(f\"Error on registering Anoncreds revocation list: {error!s}\")\n            return RegisterRevListResult(\n                revocation_list_state=RevListState(\n                    state=\"failed\", revocation_list=rev_list, reason=f\"unknownError: ${error!s}\"\n                ),\n                registration_metadata={},\n                revocation_list_metadata={},\n            )\n\n    async def update_rev_list(\n        self, prev_list: AnonCredsRevList, curr_list: AnonCredsRevList, revoked: Sequence[int], issuer_key_der: str\n    ) -&gt; RegisterRevListResult:\n        \"\"\"Update Revocation list.\n\n        Args:\n            prev_list: Previous Revocation list object\n            curr_list: Current Revocation list object\n            revoked: Revoked credential indexes\n            issuer_key_der: Issuer private key encoded in DER\n\n        Returns: Revocation list update result\n        \"\"\"\n        try:\n            return await self._submit_rev_list_entry(curr_list, issuer_key_der, prev_list, revoked)\n        except Exception as error:\n            LOGGER.error(f\"Error on updating Anoncreds revocation list: {error!s}\")\n            return RegisterRevListResult(\n                revocation_list_state=RevListState(\n                    state=\"failed\", revocation_list=curr_list, reason=f\"unknownError: ${error!s}\"\n                ),\n                registration_metadata={},\n                revocation_list_metadata={},\n            )\n\n    async def _submit_rev_list_entry(\n        self,\n        rev_list: AnonCredsRevList,\n        issuer_key_der: str,\n        prev_list: AnonCredsRevList | None = None,\n        revoked: Sequence[int] | None = None,\n    ) -&gt; RegisterRevListResult:\n        if prev_list and prev_list.rev_reg_def_id != rev_list.rev_reg_def_id:\n            return RegisterRevListResult(\n                revocation_list_state=RevListState(\n                    state=\"failed\",\n                    revocation_list=rev_list,\n                    reason=f\"Revocation registry ids do not match for previous and current list: '{prev_list.rev_reg_def_id}' != '{rev_list.rev_reg_def_id}'\",\n                ),\n                registration_metadata={},\n                revocation_list_metadata={},\n            )\n\n        rev_reg_def_result = await self.get_rev_reg_def(rev_list.rev_reg_def_id)\n\n        if not rev_reg_def_result.revocation_registry_definition:\n            return RegisterRevListResult(\n                revocation_list_state=RevListState(\n                    state=\"failed\",\n                    revocation_list=rev_list,\n                    reason=f\"AnonCreds revocation registry with id '{rev_list.rev_reg_def_id}' not found\",\n                ),\n                registration_metadata={},\n                revocation_list_metadata={},\n            )\n\n        entries_topic_id = rev_reg_def_result.revocation_registry_definition_metadata.get(\"entriesTopicId\")\n\n        if not entries_topic_id:\n            return RegisterRevListResult(\n                revocation_list_state=RevListState(\n                    state=\"failed\",\n                    revocation_list=rev_list,\n                    reason=\"notFound: Entries topic ID is missing from revocation registry metadata\",\n                ),\n                registration_metadata={},\n                revocation_list_metadata={},\n            )\n\n        entry_message = HcsRevRegEntryMessage(\n            value=RevRegEntryValue(\n                prev_accum=prev_list.current_accumulator if prev_list else None,\n                accum=rev_list.current_accumulator,\n                revoked=list(revoked) if revoked else None,\n            )\n        )\n\n        def build_message_submit_transaction(\n            message_submit_transaction: TopicMessageSubmitTransaction,\n        ) -&gt; Transaction:\n            message_submit_transaction.transaction_fee = MAX_TRANSACTION_FEE.to_tinybars()  # pyright: ignore [reportAttributeAccessIssue]\n            return message_submit_transaction.freeze_with(self._client).sign(PrivateKey.from_string(issuer_key_der))\n\n        await HcsMessageTransaction(entries_topic_id, entry_message, build_message_submit_transaction).execute(\n            self._client\n        )\n\n        return RegisterRevListResult(\n            revocation_list_state=RevListState(state=\"finished\", revocation_list=rev_list),\n            registration_metadata={},\n            revocation_list_metadata={},\n        )\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.hedera_anoncreds_registry.HederaAnonCredsRegistry.get_cred_def","title":"<code>get_cred_def(cred_def_id)</code>  <code>async</code>","text":"<p>Get a credential definition from the registry.</p> <p>Parameters:</p> Name Type Description Default <code>cred_def_id</code> <code>str</code> <p>Credential definition ID to resolve</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>GetCredDefResult</code> <p>Credential definition resolution result</p> Source code in <code>hiero_did_sdk_python/anoncreds/hedera_anoncreds_registry.py</code> <pre><code>async def get_cred_def(self, cred_def_id: str) -&gt; GetCredDefResult:\n    \"\"\"Get a credential definition from the registry.\n\n    Args:\n        cred_def_id: Credential definition ID to resolve\n\n    Returns:\n        object: Credential definition resolution result\n    \"\"\"\n    try:\n        parsed_identifier = parse_anoncreds_identifier(cred_def_id)\n\n        if parsed_identifier.object_type != AnonCredsObjectType.PUBLIC_CRED_DEF:\n            return GetCredDefResult(\n                credential_definition_id=cred_def_id,\n                resolution_metadata={\n                    \"error\": \"notFound\",\n                    \"message\": f\"Credential definition id '{cred_def_id}' is invalid\",\n                },\n                credential_definition_metadata={},\n            )\n\n        cred_def_topic_id = parsed_identifier.topic_id\n\n        cached_cred_def = self._cred_def_cache.get(cred_def_topic_id)\n\n        if cached_cred_def:\n            cred_def = cached_cred_def\n        else:\n            cred_def_payload = await self._hcs_file_service.resolve_file(cred_def_topic_id)\n            cred_def = AnonCredsCredDef.from_json(cred_def_payload.decode()) if cred_def_payload else None\n\n            if not cred_def:\n                return GetCredDefResult(\n                    credential_definition_id=cred_def_id,\n                    resolution_metadata={\n                        \"error\": \"notFound\",\n                        \"message\": f\"AnonCreds credential definition with id '{cred_def_id}' not found\",\n                    },\n                    credential_definition_metadata={},\n                )\n\n            self._cred_def_cache.set(cred_def_topic_id, cred_def)\n\n        return GetCredDefResult(\n            credential_definition=cred_def,\n            credential_definition_id=cred_def_id,\n            resolution_metadata={},\n            credential_definition_metadata={},\n        )\n    except Exception as error:\n        LOGGER.error(f\"Error on retrieving AnonCreds credential definition: {error!s}\")\n        return GetCredDefResult(\n            credential_definition_id=cred_def_id,\n            resolution_metadata={\n                \"error\": \"otherError\",\n                \"message\": f\"unable to resolve credential definition: ${error!s}\",\n            },\n            credential_definition_metadata={},\n        )\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.hedera_anoncreds_registry.HederaAnonCredsRegistry.get_rev_list","title":"<code>get_rev_list(rev_reg_id, timestamp)</code>  <code>async</code>","text":"<p>Get a revocation list from the registry.</p> <p>Parameters:</p> Name Type Description Default <code>rev_reg_id</code> <code>str</code> <p>Revocation registry ID</p> required <code>timestamp</code> <code>int</code> <p>Timestamp to resolve revocation list for</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>GetRevListResult</code> <p>Revocation list resolution result</p> Source code in <code>hiero_did_sdk_python/anoncreds/hedera_anoncreds_registry.py</code> <pre><code>async def get_rev_list(self, rev_reg_id: str, timestamp: int) -&gt; GetRevListResult:\n    \"\"\"Get a revocation list from the registry.\n\n    Args:\n        rev_reg_id: Revocation registry ID\n        timestamp: Timestamp to resolve revocation list for\n\n    Returns:\n        object: Revocation list resolution result\n    \"\"\"\n    try:\n        rev_reg_def_result = await self.get_rev_reg_def(rev_reg_id)\n\n        if not rev_reg_def_result.revocation_registry_definition:\n            return GetRevListResult(\n                revocation_registry_id=rev_reg_id,\n                resolution_metadata={\n                    \"error\": \"notFound\",\n                    \"message\": f\"AnonCreds revocation registry with id '{rev_reg_id}' not found\",\n                },\n                revocation_list_metadata={},\n            )\n\n        rev_reg_def = rev_reg_def_result.revocation_registry_definition\n        entries_topic_id = rev_reg_def_result.revocation_registry_definition_metadata.get(\"entriesTopicId\")\n\n        if not entries_topic_id:\n            return GetRevListResult(\n                revocation_registry_id=rev_reg_id,\n                resolution_metadata={\n                    \"error\": \"notFound\",\n                    \"message\": \"Entries topic ID is missing from revocation registry metadata\",\n                },\n                revocation_list_metadata={},\n            )\n\n        cached_messages = self._rev_reg_entries_messages_cache.get(entries_topic_id)\n        if cached_messages:\n            last_cached_message_timestamp = cached_messages[-1].consensus_timestamp\n\n            if last_cached_message_timestamp.seconds &gt;= timestamp:\n                borderline_timestamp = Timestamp(seconds=timestamp, nanos=0)\n                entries_messages = filter(\n                    lambda message: message.consensus_timestamp.seconds &lt; timestamp\n                    or message.consensus_timestamp == borderline_timestamp,\n                    cached_messages,\n                )\n                entries = [cast(AnonCredsRevRegEntry, message.message) for message in entries_messages]\n\n                # This means that requested timestamp is before the actual registration of rev list\n                # In such case, we want to return initial state for the list (by adding first message to entries)\n                if len(entries) == 0:\n                    entries.append(cast(AnonCredsRevRegEntry, cached_messages[0].message))\n\n                return GetRevListResult(\n                    revocation_registry_id=rev_reg_id,\n                    revocation_list=AnonCredsRevList.from_rev_reg_entries(\n                        entries, rev_reg_id, rev_reg_def, timestamp\n                    ),\n                    resolution_metadata={},\n                    revocation_list_metadata={},\n                )\n            else:\n                new_messages = await HcsMessageResolver(\n                    topic_id=entries_topic_id,\n                    message_type=HcsRevRegEntryMessage,\n                    timestamp_from=last_cached_message_timestamp,\n                    timestamp_to=Timestamp(seconds=timestamp, nanos=0),\n                    include_response_metadata=True,\n                ).execute(self._client)\n\n                # Note: 'chain' function is used instead of lists sum due to significantly better performance on large lists\n                # See: https://docs.python.org/3/library/itertools.html, https://stackoverflow.com/a/41772165\n                entries_messages = (\n                    list(chain(cached_messages, cast(list[HcsMessageWithResponseMetadata], new_messages)))\n                    if len(new_messages) &gt; 0\n                    else cached_messages\n                )\n\n                self._rev_reg_entries_messages_cache.set(entries_topic_id, entries_messages)\n\n                entries = [cast(AnonCredsRevRegEntry, message.message) for message in entries_messages]\n\n                return GetRevListResult(\n                    revocation_registry_id=rev_reg_id,\n                    revocation_list=AnonCredsRevList.from_rev_reg_entries(\n                        entries, rev_reg_id, rev_reg_def, timestamp\n                    ),\n                    resolution_metadata={},\n                    revocation_list_metadata={},\n                )\n\n        entries_messages = await HcsMessageResolver(\n            topic_id=entries_topic_id,\n            message_type=HcsRevRegEntryMessage,\n            timestamp_to=Timestamp(seconds=timestamp, nanos=0),\n            include_response_metadata=True,\n        ).execute(self._client)\n\n        if len(entries_messages) == 0:\n            # If returned entries list is empty, we need to fetch the first message and check if list is registered\n            # It's possible that requested timestamp is before the actual registration of rev list -&gt; we want to return initial state for the list (by adding first message to entries)\n\n            # The second request looks redundant here, but it should be the rare case that will be subsequently handled by cache\n            entries_messages = await HcsMessageResolver(\n                topic_id=entries_topic_id,\n                message_type=HcsRevRegEntryMessage,\n                limit=1,\n                include_response_metadata=True,\n            ).execute(self._client)\n\n            if len(entries_messages) == 0:\n                return GetRevListResult(\n                    revocation_registry_id=rev_reg_id,\n                    resolution_metadata={\n                        \"error\": \"notFound\",\n                        \"message\": f\"Registered revocation list for registry id '{rev_reg_id}' is not found\",\n                    },\n                    revocation_list_metadata={},\n                )\n\n        entries_messages = cast(list[HcsMessageWithResponseMetadata], entries_messages)\n        self._rev_reg_entries_messages_cache.set(entries_topic_id, entries_messages)\n\n        entries = [cast(AnonCredsRevRegEntry, message.message) for message in entries_messages]\n\n        return GetRevListResult(\n            revocation_registry_id=rev_reg_id,\n            revocation_list=AnonCredsRevList.from_rev_reg_entries(entries, rev_reg_id, rev_reg_def, timestamp),\n            resolution_metadata={},\n            revocation_list_metadata={},\n        )\n\n    except Exception as error:\n        LOGGER.error(f\"Error on retrieving AnonCreds revocation list: {error!s}\")\n        return GetRevListResult(\n            revocation_registry_id=rev_reg_id,\n            resolution_metadata={\n                \"error\": \"otherError\",\n                \"message\": f\"Unable to resolve revocation list: ${error!s}\",\n            },\n            revocation_list_metadata={},\n        )\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.hedera_anoncreds_registry.HederaAnonCredsRegistry.get_rev_reg_def","title":"<code>get_rev_reg_def(revocation_registry_definition_id)</code>  <code>async</code>","text":"<p>Get a revocation registry definition from the registry.</p> <p>Parameters:</p> Name Type Description Default <code>revocation_registry_definition_id</code> <code>str</code> <p>Revocation registry definition ID to resolve</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>GetRevRegDefResult</code> <p>Revocation registry definition resolution result</p> Source code in <code>hiero_did_sdk_python/anoncreds/hedera_anoncreds_registry.py</code> <pre><code>async def get_rev_reg_def(self, revocation_registry_definition_id: str) -&gt; GetRevRegDefResult:\n    \"\"\"Get a revocation registry definition from the registry.\n\n    Args:\n        revocation_registry_definition_id: Revocation registry definition ID to resolve\n\n    Returns:\n        object: Revocation registry definition resolution result\n    \"\"\"\n    try:\n        parsed_identifier = parse_anoncreds_identifier(revocation_registry_definition_id)\n\n        if parsed_identifier.object_type != AnonCredsObjectType.REV_REG:\n            return GetRevRegDefResult(\n                revocation_registry_definition_id=revocation_registry_definition_id,\n                resolution_metadata={\n                    \"error\": \"notFound\",\n                    \"message\": f\"Revocation registry id '{revocation_registry_definition_id}' is invalid\",\n                },\n                revocation_registry_definition_metadata={},\n            )\n\n        rev_reg_def_topic_id = parsed_identifier.topic_id\n\n        cached_rev_reg_def_with_metadata = self._rev_reg_def_cache.get(rev_reg_def_topic_id)\n\n        if cached_rev_reg_def_with_metadata:\n            rev_reg_def_with_metadata = cached_rev_reg_def_with_metadata\n        else:\n            rev_reg_def_payload = await self._hcs_file_service.resolve_file(rev_reg_def_topic_id)\n            rev_reg_def_with_metadata = (\n                RevRegDefWithHcsMetadata.from_json(rev_reg_def_payload.decode()) if rev_reg_def_payload else None\n            )\n\n            if not rev_reg_def_with_metadata:\n                return GetRevRegDefResult(\n                    revocation_registry_definition_id=revocation_registry_definition_id,\n                    resolution_metadata={\n                        \"error\": \"notFound\",\n                        \"message\": f\"AnonCreds revocation registry with id '{revocation_registry_definition_id}' not found\",\n                    },\n                    revocation_registry_definition_metadata={},\n                )\n\n            self._rev_reg_def_cache.set(rev_reg_def_topic_id, rev_reg_def_with_metadata)\n\n        return GetRevRegDefResult(\n            revocation_registry_definition=rev_reg_def_with_metadata.rev_reg_def,\n            revocation_registry_definition_id=revocation_registry_definition_id,\n            resolution_metadata={},\n            revocation_registry_definition_metadata={**rev_reg_def_with_metadata.hcs_metadata},\n        )\n    except Exception as error:\n        LOGGER.error(f\"Error on retrieving AnonCreds revocation registry definition: {error!s}\")\n        return GetRevRegDefResult(\n            revocation_registry_definition_id=revocation_registry_definition_id,\n            resolution_metadata={\n                \"error\": \"otherError\",\n                \"message\": f\"unable to resolve revocation registry definition: ${error!s}\",\n            },\n            revocation_registry_definition_metadata={},\n        )\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.hedera_anoncreds_registry.HederaAnonCredsRegistry.get_schema","title":"<code>get_schema(schema_id)</code>  <code>async</code>","text":"<p>Get a schema from the registry.</p> <p>Parameters:</p> Name Type Description Default <code>schema_id</code> <code>str</code> <p>Schema ID to resolver</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>GetSchemaResult</code> <p>Schema resolution result</p> Source code in <code>hiero_did_sdk_python/anoncreds/hedera_anoncreds_registry.py</code> <pre><code>async def get_schema(self, schema_id: str) -&gt; GetSchemaResult:\n    \"\"\"Get a schema from the registry.\n\n    Args:\n        schema_id: Schema ID to resolver\n\n    Returns:\n        object: Schema resolution result\n    \"\"\"\n    try:\n        parsed_identifier = parse_anoncreds_identifier(schema_id)\n\n        if parsed_identifier.object_type != AnonCredsObjectType.SCHEMA:\n            return GetSchemaResult(\n                schema_id=schema_id,\n                resolution_metadata={\n                    \"error\": \"notFound\",\n                    \"message\": f\"AnonCreds Schema id '{schema_id}' is invalid\",\n                },\n                schema_metadata={},\n            )\n\n        schema_topic_id = parsed_identifier.topic_id\n\n        cached_schema = self._schema_cache.get(schema_topic_id)\n\n        if cached_schema:\n            schema = cached_schema\n        else:\n            schema_payload = await self._hcs_file_service.resolve_file(parsed_identifier.topic_id)\n            schema = AnonCredsSchema.from_json(schema_payload.decode()) if schema_payload else None\n\n            if not schema:\n                return GetSchemaResult(\n                    schema_id=schema_id,\n                    resolution_metadata={\n                        \"error\": \"notFound\",\n                        \"message\": f\"AnonCreds schema with id '{schema_id}' not found\",\n                    },\n                    schema_metadata={},\n                )\n\n            self._schema_cache.set(schema_topic_id, schema)\n\n        return GetSchemaResult(schema=schema, schema_id=schema_id, resolution_metadata={}, schema_metadata={})\n    except Exception as error:\n        LOGGER.error(f\"Error on retrieving AnonCreds Schema: {error!s}\")\n        return GetSchemaResult(\n            schema_id=schema_id,\n            resolution_metadata={\n                \"error\": \"otherError\",\n                \"message\": f\"unable to resolve schema: ${error!s}\",\n            },\n            schema_metadata={},\n        )\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.hedera_anoncreds_registry.HederaAnonCredsRegistry.register_cred_def","title":"<code>register_cred_def(cred_def, issuer_key_der)</code>  <code>async</code>","text":"<p>Register Credential Definition.</p> <p>Parameters:</p> Name Type Description Default <code>cred_def</code> <code>AnonCredsCredDef</code> <p>Credential definition object to register</p> required <code>issuer_key_der</code> <code>str</code> <p>Issuer private key encoded in DER</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>RegisterCredDefResult</code> <p>Credential definition registration result</p> Source code in <code>hiero_did_sdk_python/anoncreds/hedera_anoncreds_registry.py</code> <pre><code>async def register_cred_def(self, cred_def: AnonCredsCredDef, issuer_key_der: str) -&gt; RegisterCredDefResult:\n    \"\"\"Register Credential Definition.\n\n    Args:\n        cred_def: Credential definition object to register\n        issuer_key_der: Issuer private key encoded in DER\n\n    Returns:\n        object: Credential definition registration result\n    \"\"\"\n    try:\n        hcs_file_payload = cred_def.to_json().encode()\n        cred_def_topic_id = await self._hcs_file_service.submit_file(hcs_file_payload, issuer_key_der)\n\n        return RegisterCredDefResult(\n            credential_definition_state=CredDefState(\n                state=\"finished\",\n                credential_definition=cred_def,\n                credential_definition_id=build_anoncreds_identifier(\n                    cred_def.issuer_id, cred_def_topic_id, AnonCredsObjectType.PUBLIC_CRED_DEF\n                ),\n            ),\n            registration_metadata={},\n            credential_definition_metadata={},\n        )\n    except Exception as error:\n        LOGGER.error(f\"Error on registering Anoncreds Cred Def: {error!s}\")\n        return RegisterCredDefResult(\n            credential_definition_state=CredDefState(\n                state=\"failed\", credential_definition=cred_def, reason=f\"unknownError: ${error!s}\"\n            ),\n            registration_metadata={},\n            credential_definition_metadata={},\n        )\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.hedera_anoncreds_registry.HederaAnonCredsRegistry.register_rev_list","title":"<code>register_rev_list(rev_list, issuer_key_der)</code>  <code>async</code>","text":"<p>Register Revocation list.</p> <p>Parameters:</p> Name Type Description Default <code>rev_list</code> <code>AnonCredsRevList</code> <p>Revocation list object to register</p> required <code>issuer_key_der</code> <code>str</code> <p>Issuer private key encoded in DER</p> required <p>Returns: Revocation list registration result</p> Source code in <code>hiero_did_sdk_python/anoncreds/hedera_anoncreds_registry.py</code> <pre><code>async def register_rev_list(self, rev_list: AnonCredsRevList, issuer_key_der: str) -&gt; RegisterRevListResult:\n    \"\"\"Register Revocation list.\n\n    Args:\n        rev_list: Revocation list object to register\n        issuer_key_der: Issuer private key encoded in DER\n\n    Returns: Revocation list registration result\n    \"\"\"\n    try:\n        return await self._submit_rev_list_entry(rev_list, issuer_key_der)\n    except Exception as error:\n        LOGGER.error(f\"Error on registering Anoncreds revocation list: {error!s}\")\n        return RegisterRevListResult(\n            revocation_list_state=RevListState(\n                state=\"failed\", revocation_list=rev_list, reason=f\"unknownError: ${error!s}\"\n            ),\n            registration_metadata={},\n            revocation_list_metadata={},\n        )\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.hedera_anoncreds_registry.HederaAnonCredsRegistry.register_rev_reg_def","title":"<code>register_rev_reg_def(rev_reg_def, issuer_key_der)</code>  <code>async</code>","text":"<p>Register Revocation registry definition.</p> <p>Parameters:</p> Name Type Description Default <code>rev_reg_def</code> <code>AnonCredsRevRegDef</code> <p>Revocation registry definition object to register</p> required <code>issuer_key_der</code> <code>str</code> <p>Issuer private key encoded in DER</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>RegisterRevRegDefResult</code> <p>Revocation registry definition registration result</p> Source code in <code>hiero_did_sdk_python/anoncreds/hedera_anoncreds_registry.py</code> <pre><code>async def register_rev_reg_def(\n    self, rev_reg_def: AnonCredsRevRegDef, issuer_key_der: str\n) -&gt; RegisterRevRegDefResult:\n    \"\"\"Register Revocation registry definition.\n\n    Args:\n        rev_reg_def: Revocation registry definition object to register\n        issuer_key_der: Issuer private key encoded in DER\n\n    Returns:\n        object: Revocation registry definition registration result\n    \"\"\"\n    try:\n        issuer_key = PrivateKey.from_string(issuer_key_der)\n\n        entries_topic_options = HcsTopicOptions(submit_key=issuer_key.public_key())\n        entries_topic_id = await self._hcs_topic_service.create_topic(entries_topic_options, [issuer_key])\n\n        rev_reg_def_with_metadata = RevRegDefWithHcsMetadata(\n            rev_reg_def=rev_reg_def, hcs_metadata={\"entriesTopicId\": entries_topic_id}\n        )\n\n        hcs_file_payload = rev_reg_def_with_metadata.to_json().encode()\n        rev_reg_def_topic_id = await self._hcs_file_service.submit_file(hcs_file_payload, issuer_key_der)\n\n        # We want to cache registry definition right away\n        # Helps to avoid potential cases where issuer pushes rev entries immediately but registry definition data (HCS-1 messages) is not propagated to mirror nodes yet\n        self._rev_reg_def_cache.set(rev_reg_def_topic_id, rev_reg_def_with_metadata)\n\n        return RegisterRevRegDefResult(\n            revocation_registry_definition_state=RevRegDefState(\n                state=\"finished\",\n                revocation_registry_definition=rev_reg_def,\n                revocation_registry_definition_id=build_anoncreds_identifier(\n                    rev_reg_def.issuer_id, rev_reg_def_topic_id, AnonCredsObjectType.REV_REG\n                ),\n            ),\n            registration_metadata={},\n            revocation_registry_definition_metadata={**rev_reg_def_with_metadata.hcs_metadata},\n        )\n    except Exception as error:\n        LOGGER.error(f\"Error on registering Anoncreds Revocation registry definition: {error!s}\")\n        return RegisterRevRegDefResult(\n            revocation_registry_definition_state=RevRegDefState(\n                state=\"failed\", revocation_registry_definition=rev_reg_def, reason=f\"unknownError: ${error!s}\"\n            ),\n            registration_metadata={},\n            revocation_registry_definition_metadata={},\n        )\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.hedera_anoncreds_registry.HederaAnonCredsRegistry.register_schema","title":"<code>register_schema(schema, issuer_key_der)</code>  <code>async</code>","text":"<p>Register Schema.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>AnonCredsSchema</code> <p>Schema object to register</p> required <code>issuer_key_der</code> <code>str</code> <p>Issuer private key encoded in DER format</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>RegisterSchemaResult</code> <p>Schema registration result</p> Source code in <code>hiero_did_sdk_python/anoncreds/hedera_anoncreds_registry.py</code> <pre><code>async def register_schema(self, schema: AnonCredsSchema, issuer_key_der: str) -&gt; RegisterSchemaResult:\n    \"\"\"Register Schema.\n\n    Args:\n        schema: Schema object to register\n        issuer_key_der: Issuer private key encoded in DER format\n\n    Returns:\n        object: Schema registration result\n    \"\"\"\n    try:\n        hcs_file_payload = schema.to_json().encode()\n        schema_topic_id = await self._hcs_file_service.submit_file(hcs_file_payload, issuer_key_der)\n\n        return RegisterSchemaResult(\n            schema_state=SchemaState(\n                state=\"finished\",\n                schema=schema,\n                schema_id=build_anoncreds_identifier(schema.issuer_id, schema_topic_id, AnonCredsObjectType.SCHEMA),\n            ),\n            schema_metadata={},\n            registration_metadata={},\n        )\n    except Exception as error:\n        LOGGER.error(f\"Error on registering Anoncreds Schema: {error!s}\")\n        return RegisterSchemaResult(\n            schema_state=SchemaState(state=\"failed\", schema=schema, reason=f\"unknownError: ${error!s}\"),\n            schema_metadata={},\n            registration_metadata={},\n        )\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.hedera_anoncreds_registry.HederaAnonCredsRegistry.update_rev_list","title":"<code>update_rev_list(prev_list, curr_list, revoked, issuer_key_der)</code>  <code>async</code>","text":"<p>Update Revocation list.</p> <p>Parameters:</p> Name Type Description Default <code>prev_list</code> <code>AnonCredsRevList</code> <p>Previous Revocation list object</p> required <code>curr_list</code> <code>AnonCredsRevList</code> <p>Current Revocation list object</p> required <code>revoked</code> <code>Sequence[int]</code> <p>Revoked credential indexes</p> required <code>issuer_key_der</code> <code>str</code> <p>Issuer private key encoded in DER</p> required <p>Returns: Revocation list update result</p> Source code in <code>hiero_did_sdk_python/anoncreds/hedera_anoncreds_registry.py</code> <pre><code>async def update_rev_list(\n    self, prev_list: AnonCredsRevList, curr_list: AnonCredsRevList, revoked: Sequence[int], issuer_key_der: str\n) -&gt; RegisterRevListResult:\n    \"\"\"Update Revocation list.\n\n    Args:\n        prev_list: Previous Revocation list object\n        curr_list: Current Revocation list object\n        revoked: Revoked credential indexes\n        issuer_key_der: Issuer private key encoded in DER\n\n    Returns: Revocation list update result\n    \"\"\"\n    try:\n        return await self._submit_rev_list_entry(curr_list, issuer_key_der, prev_list, revoked)\n    except Exception as error:\n        LOGGER.error(f\"Error on updating Anoncreds revocation list: {error!s}\")\n        return RegisterRevListResult(\n            revocation_list_state=RevListState(\n                state=\"failed\", revocation_list=curr_list, reason=f\"unknownError: ${error!s}\"\n            ),\n            registration_metadata={},\n            revocation_list_metadata={},\n        )\n</code></pre>"},{"location":"modules/anoncreds/#models-and-types","title":"Models and types","text":""},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.models.AnonCredsCredDef","title":"<code>AnonCredsCredDef</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>Model representing AnonCreds credential definition.</p> <p>Attributes:</p> Name Type Description <code>issuer_id</code> <code>str</code> <p>Credential definition issuer DID</p> <code>schema_id</code> <code>str</code> <p>Schema ID</p> <code>type_</code> <code>str</code> <p>Credential definition type. Only \"CL\" type is currently supported</p> <code>tag</code> <code>str</code> <p>Credential definition tag</p> <code>value</code> <code>CredDefValue</code> <p>Definition value object</p> Source code in <code>hiero_did_sdk_python/anoncreds/models/credential_definition.py</code> <pre><code>@dataclass\nclass AnonCredsCredDef(Serializable):\n    \"\"\"Model representing AnonCreds credential definition.\n\n    Attributes:\n        issuer_id: Credential definition issuer DID\n        schema_id: Schema ID\n        type_: Credential definition type. Only \"CL\" type is currently supported\n        tag: Credential definition tag\n        value: Definition value object\n    \"\"\"\n\n    issuer_id: str\n    schema_id: str\n    type_: ClassVar[str] = CREDENTIAL_DEFINITION_TYPE\n    tag: str\n    value: CredDefValue\n\n    @classmethod\n    def from_json_payload(cls, payload: dict):\n        match payload:\n            case {\"issuerId\": issuer_id, \"schemaId\": schema_id, \"type\": type_, \"tag\": tag, \"value\": value}:\n                if type_ != CREDENTIAL_DEFINITION_TYPE:\n                    raise Exception(f\"Unsupported Anoncreds Cred Def type: {type_}\")\n                return cls(\n                    issuer_id=issuer_id, schema_id=schema_id, tag=tag, value=CredDefValue.from_json_payload(value)\n                )\n            case _:\n                raise Exception(f\"{cls.__name__} JSON parsing failed: Invalid JSON structure\")\n\n    def get_json_payload(self):\n        return {\n            \"issuerId\": self.issuer_id,\n            \"schemaId\": self.schema_id,\n            \"type\": self.type_,\n            \"tag\": self.tag,\n            \"value\": self.value.get_json_payload(),\n        }\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.models.AnonCredsRevList","title":"<code>AnonCredsRevList</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>Model representing AnonCreds revocation list object.</p> <p>Attributes:</p> Name Type Description <code>issuer_id</code> <code>str</code> <p>Revocation registry issuer DID</p> <code>rev_reg_def_id</code> <code>str</code> <p>Revocation registry definition ID</p> <code>revocation_list</code> <code>list[int]</code> <p>Revocation list that represents state (revoked/non-revoked) of each credential in registry, list size correspond to number of credentials that revocation registry can hold</p> <code>current_accumulator</code> <code>str</code> <p>Current value of CL accumulator</p> <code>timestamp</code> <code>int | None</code> <p>Timestamp associated with revocation list instance</p> Source code in <code>hiero_did_sdk_python/anoncreds/models/revocation/revocation_list.py</code> <pre><code>@dataclass\nclass AnonCredsRevList(Serializable):\n    \"\"\"Model representing AnonCreds revocation list object.\n\n    Attributes:\n        issuer_id: Revocation registry issuer DID\n        rev_reg_def_id: Revocation registry definition ID\n        revocation_list: Revocation list that represents state (revoked/non-revoked) of each credential in registry, list size correspond to number of credentials that revocation registry can hold\n        current_accumulator: Current value of CL accumulator\n        timestamp: Timestamp associated with revocation list instance\n    \"\"\"\n\n    issuer_id: str\n    rev_reg_def_id: str\n    revocation_list: list[int]\n    current_accumulator: str\n    timestamp: int | None = None\n\n    @classmethod\n    def from_rev_reg_entries(\n        cls,\n        entries: list[AnonCredsRevRegEntry],\n        rev_reg_id: str,\n        rev_reg_def: AnonCredsRevRegDef,\n        timestamp: int | None = None,\n    ):\n        \"\"\"Build revocation list object from corresponding revocation registry entries.\n\n        Args:\n            entries: List of revocation registry entries to build state from\n            rev_reg_id: Revocation registry ID\n            rev_reg_def: Revocation registry definition object\n            timestamp: Requested timestamp to associate revocation list with\n        \"\"\"\n        revoked_indexes = []\n\n        for entry in entries:\n            if entry.value.revoked:\n                revoked_indexes += entry.value.revoked\n\n        rev_list_bit_array = _indexes_to_bit_array(revoked_indexes, rev_reg_def.value.max_cred_num)\n        accum = entries[-1].value.accum\n\n        return cls(\n            issuer_id=rev_reg_def.issuer_id,\n            rev_reg_def_id=rev_reg_id,\n            revocation_list=rev_list_bit_array,\n            current_accumulator=accum,\n            timestamp=timestamp,\n        )\n\n    @classmethod\n    def from_json_payload(cls, payload: dict):\n        match payload:\n            case {\n                \"issuerId\": issuer_id,\n                \"revRegDefId\": rev_reg_def_id,\n                \"revocationList\": revocation_list,\n                \"currentAccumulator\": current_accumulator,\n                **rest,\n            }:\n                return cls(\n                    issuer_id=issuer_id,\n                    rev_reg_def_id=rev_reg_def_id,\n                    revocation_list=revocation_list,\n                    current_accumulator=current_accumulator,\n                    timestamp=rest.get(\"timestamp\"),\n                )\n            case _:\n                raise Exception(f\"{cls.__name__} JSON parsing failed: Invalid JSON structure\")\n\n    def get_json_payload(self):\n        payload = {\n            \"issuerId\": self.issuer_id,\n            \"revRegDefId\": self.rev_reg_def_id,\n            \"revocationList\": self.revocation_list,\n            \"currentAccumulator\": self.current_accumulator,\n        }\n\n        if self.timestamp:\n            payload[\"timestamp\"] = self.timestamp\n\n        return payload\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.models.AnonCredsRevList.from_rev_reg_entries","title":"<code>from_rev_reg_entries(entries, rev_reg_id, rev_reg_def, timestamp=None)</code>  <code>classmethod</code>","text":"<p>Build revocation list object from corresponding revocation registry entries.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>list[AnonCredsRevRegEntry]</code> <p>List of revocation registry entries to build state from</p> required <code>rev_reg_id</code> <code>str</code> <p>Revocation registry ID</p> required <code>rev_reg_def</code> <code>AnonCredsRevRegDef</code> <p>Revocation registry definition object</p> required <code>timestamp</code> <code>int | None</code> <p>Requested timestamp to associate revocation list with</p> <code>None</code> Source code in <code>hiero_did_sdk_python/anoncreds/models/revocation/revocation_list.py</code> <pre><code>@classmethod\ndef from_rev_reg_entries(\n    cls,\n    entries: list[AnonCredsRevRegEntry],\n    rev_reg_id: str,\n    rev_reg_def: AnonCredsRevRegDef,\n    timestamp: int | None = None,\n):\n    \"\"\"Build revocation list object from corresponding revocation registry entries.\n\n    Args:\n        entries: List of revocation registry entries to build state from\n        rev_reg_id: Revocation registry ID\n        rev_reg_def: Revocation registry definition object\n        timestamp: Requested timestamp to associate revocation list with\n    \"\"\"\n    revoked_indexes = []\n\n    for entry in entries:\n        if entry.value.revoked:\n            revoked_indexes += entry.value.revoked\n\n    rev_list_bit_array = _indexes_to_bit_array(revoked_indexes, rev_reg_def.value.max_cred_num)\n    accum = entries[-1].value.accum\n\n    return cls(\n        issuer_id=rev_reg_def.issuer_id,\n        rev_reg_def_id=rev_reg_id,\n        revocation_list=rev_list_bit_array,\n        current_accumulator=accum,\n        timestamp=timestamp,\n    )\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.models.AnonCredsRevRegDef","title":"<code>AnonCredsRevRegDef</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>Model representing AnonCreds revocation registry definition.</p> <p>Attributes:</p> Name Type Description <code>issuer_id</code> <code>str</code> <p>Revocation registry issuer DID</p> <code>type_</code> <code>str</code> <p>Revocation registry type. Only \"CL_ACCUM\" type is currently supported</p> <code>cred_def_id</code> <code>str</code> <p>Credential definition ID</p> <code>tag</code> <code>str</code> <p>Revocation registry tag</p> <code>value</code> <code>RevRegDefValue</code> <p>Definition value object</p> Source code in <code>hiero_did_sdk_python/anoncreds/models/revocation/revocation_registry_definition.py</code> <pre><code>@dataclass\nclass AnonCredsRevRegDef(Serializable):\n    \"\"\"Model representing AnonCreds revocation registry definition.\n\n    Attributes:\n        issuer_id: Revocation registry issuer DID\n        type_: Revocation registry type. Only \"CL_ACCUM\" type is currently supported\n        cred_def_id: Credential definition ID\n        tag: Revocation registry tag\n        value: Definition value object\n    \"\"\"\n\n    issuer_id: str\n    type_: ClassVar[str] = REVOCATION_REGISTRY_TYPE\n    cred_def_id: str\n    tag: str\n    value: RevRegDefValue\n\n    @classmethod\n    def from_json_payload(cls, payload: dict):\n        match payload:\n            case {\"issuerId\": issuer_id, \"type\": type_, \"credDefId\": cred_def_id, \"tag\": tag, \"value\": value}:\n                if type_ != REVOCATION_REGISTRY_TYPE:\n                    raise Exception(f\"Unsupported Anoncreds Revocation Registry type: {type_}\")\n                return cls(\n                    issuer_id=issuer_id, cred_def_id=cred_def_id, tag=tag, value=RevRegDefValue.from_json_payload(value)\n                )\n            case _:\n                raise Exception(f\"{cls.__name__} JSON parsing failed: Invalid JSON structure\")\n\n    def get_json_payload(self):\n        return {\n            \"issuerId\": self.issuer_id,\n            \"type\": self.type_,\n            \"credDefId\": self.cred_def_id,\n            \"tag\": self.tag,\n            \"value\": self.value.get_json_payload(),\n        }\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.models.AnonCredsRevRegEntry","title":"<code>AnonCredsRevRegEntry</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>Model representing AnonCreds revocation registry entry.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>RevRegEntryValue</code> <p>Entry value object</p> <code>ver</code> <code>str</code> <p>Entry version</p> Source code in <code>hiero_did_sdk_python/anoncreds/models/revocation/revocation_registry_entry.py</code> <pre><code>@dataclass\nclass AnonCredsRevRegEntry(Serializable):\n    \"\"\"Model representing AnonCreds revocation registry entry.\n\n    Attributes:\n        value: Entry value object\n        ver: Entry version\n    \"\"\"\n\n    value: RevRegEntryValue\n    ver: str = DEFAULT_REV_REG_ENTRY_VERSION\n\n    @classmethod\n    def from_json_payload(cls, payload: dict):\n        match payload:\n            case {\"payload\": compressed_str}:\n                compressed_bytes = b64_to_bytes(compressed_str)\n                entry_params = json.loads(ZstdDecompressor().decompress(compressed_bytes))\n                return cls._from_json_payload_raw(entry_params)\n            case _:\n                raise Exception(f\"{cls.__name__} JSON parsing failed: Invalid JSON structure\")\n\n    def get_json_payload(self):\n        payload_str = json.dumps(self._get_json_payload_raw()).encode()\n        compressed_payload = ZstdCompressor().compress(payload_str)\n        return {\"payload\": bytes_to_b64(compressed_payload)}\n\n    @classmethod\n    def _from_json_payload_raw(cls, payload: dict):\n        match payload:\n            case {\"ver\": ver, \"value\": value}:\n                return cls(ver=ver, value=RevRegEntryValue.from_json_payload(value))\n            case _:\n                raise Exception(f\"{cls.__name__} JSON parsing failed: Invalid JSON structure\")\n\n    def _get_json_payload_raw(self):\n        return {\"ver\": self.ver, \"value\": self.value.get_json_payload()}\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.models.AnonCredsSchema","title":"<code>AnonCredsSchema</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>Model representing AnonCreds schema.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Schema name</p> <code>issuer_id</code> <code>str</code> <p>Schema issuer DID</p> <code>attr_names</code> <code>list[str]</code> <p>List of schema attribute names</p> <code>version</code> <code>str</code> <p>Schema version</p> Source code in <code>hiero_did_sdk_python/anoncreds/models/schema.py</code> <pre><code>@dataclass\nclass AnonCredsSchema(Serializable):\n    \"\"\"Model representing AnonCreds schema.\n\n    Attributes:\n        name: Schema name\n        issuer_id: Schema issuer DID\n        attr_names: List of schema attribute names\n        version: Schema version\n    \"\"\"\n\n    name: str\n    issuer_id: str\n    attr_names: list[str]\n    version: str\n\n    @classmethod\n    def from_json_payload(cls, payload: dict):\n        match payload:\n            case {\"name\": name, \"issuerId\": issuer_id, \"attrNames\": attr_names, \"version\": version}:\n                return cls(name=name, issuer_id=issuer_id, attr_names=attr_names, version=version)\n            case _:\n                raise Exception(f\"{cls.__name__} JSON parsing failed: Invalid JSON structure\")\n\n    def get_json_payload(self):\n        return {\"name\": self.name, \"issuerId\": self.issuer_id, \"attrNames\": self.attr_names, \"version\": self.version}\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.models.CredDefValue","title":"<code>CredDefValue</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>Model representing AnonCreds credential definition value.</p> <p>Attributes:</p> Name Type Description <code>primary</code> <code>CredDefValuePrimary</code> <p>Credential definition primary value</p> <code>revocation</code> <code>CredDefValueRevocation | None</code> <p>Credential definition revocation-specific value</p> Source code in <code>hiero_did_sdk_python/anoncreds/models/credential_definition.py</code> <pre><code>@dataclass\nclass CredDefValue(Serializable):\n    \"\"\"Model representing AnonCreds credential definition value.\n\n    Attributes:\n        primary: Credential definition primary value\n        revocation: Credential definition revocation-specific value\n    \"\"\"\n\n    primary: CredDefValuePrimary\n    revocation: CredDefValueRevocation | None\n\n    @classmethod\n    def from_json_payload(cls, payload: dict):\n        match payload:\n            case {\"primary\": primary, \"revocation\": revocation}:\n                return cls(\n                    CredDefValuePrimary.from_json_payload(primary), CredDefValueRevocation.from_json_payload(revocation)\n                )\n            case {\"primary\": primary}:\n                return cls(CredDefValuePrimary.from_json_payload(primary), None)\n            case _:\n                raise Exception(f\"{cls.__name__} JSON parsing failed: Invalid JSON structure\")\n\n    def get_json_payload(self):\n        payload = {\"primary\": self.primary.get_json_payload()}\n\n        if self.revocation:\n            payload[\"revocation\"] = self.revocation.get_json_payload()\n\n        return payload\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.models.CredDefValuePrimary","title":"<code>CredDefValuePrimary</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>Model of primary credential definition value.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>str</code> <p>Safe RSA-2048 number</p> required <code>s</code> <code>str</code> <p>Randomly selected quadratic residue of n</p> required <code>r</code> <code>dict</code> <p>Object that defines a CL-RSA public key fragment for each attribute in the credential</p> required <code>rctxt</code> <code>str</code> <p>Equal to s^(xrctxt), where xrctxt is a randomly selected integer between 2 and p'q'-1</p> required <code>z</code> <code>str</code> <p>is equal to s^(xz), where xz is a randomly selected integer between 2 and p'q'-1. This makes up part of the CL-RSA public key, independent of the message blocks being signed</p> required Source code in <code>hiero_did_sdk_python/anoncreds/models/credential_definition.py</code> <pre><code>@dataclass\nclass CredDefValuePrimary(Serializable):\n    \"\"\"Model of primary credential definition value.\n\n    Args:\n        n: Safe RSA-2048 number\n        s: Randomly selected quadratic residue of n\n        r: Object that defines a CL-RSA public key fragment for each attribute in the credential\n        rctxt: Equal to s^(xrctxt), where xrctxt is a randomly selected integer between 2 and p'q'-1\n        z: is equal to s^(xz), where xz is a randomly selected integer between 2\n            and p'q'-1. This makes up part of the CL-RSA public key, independent of\n            the message blocks being signed\n    \"\"\"\n\n    n: str\n    s: str\n    r: dict\n    rctxt: str\n    z: str\n\n    @classmethod\n    def from_json_payload(cls, payload: dict):\n        match payload:\n            case {\"n\": n, \"s\": s, \"r\": r, \"rctxt\": rctxt, \"z\": z}:\n                return cls(n, s, r, rctxt, z)\n            case _:\n                raise Exception(f\"{cls.__name__} JSON parsing failed: Invalid JSON structure\")\n\n    def get_json_payload(self):\n        return self.__dict__\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.models.CredDefValueRevocation","title":"<code>CredDefValueRevocation</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>Model of revocation-specific credential definition value.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>str</code> <p>Generator for the elliptic curve group G1</p> required <code>g_dash</code> <code>str</code> <p>Generator for the elliptic curve group G2</p> required <code>h</code> <code>str</code> <p>Elliptic curve point selected uniformly at random from G1</p> required <code>h0</code> <code>str</code> <p>Elliptic curve point selected uniformly at random from G1</p> required <code>h1</code> <code>str</code> <p>Elliptic curve point selected uniformly at random from G1</p> required <code>h2</code> <code>str</code> <p>Elliptic curve point selected uniformly at random from G1</p> required <code>htilde</code> <code>str</code> <p>Elliptic curve point selected uniformly at random from G1</p> required <code>h_cap</code> <code>str</code> <p>Elliptic curve point selected uniformly at random from G2</p> required <code>u</code> <code>str</code> <p>Elliptic curve point selected uniformly at random from G2</p> required <code>pk</code> <code>str</code> <p>Public key in G1 for the issuer with respect to this accumulator, computed as g^sk (in multiplicative notation), where sk is from r_key above</p> required <code>y</code> <code>str</code> <p>Elliptic curve point in G2. computed as h_cap^x (in multiplicative notation), where x is from r_key above</p> required Source code in <code>hiero_did_sdk_python/anoncreds/models/credential_definition.py</code> <pre><code>@dataclass\nclass CredDefValueRevocation(Serializable):\n    \"\"\"Model of revocation-specific credential definition value.\n\n    Args:\n        g: Generator for the elliptic curve group G1\n        g_dash: Generator for the elliptic curve group G2\n        h: Elliptic curve point selected uniformly at random from G1\n        h0: Elliptic curve point selected uniformly at random from G1\n        h1: Elliptic curve point selected uniformly at random from G1\n        h2: Elliptic curve point selected uniformly at random from G1\n        htilde: Elliptic curve point selected uniformly at random from G1\n        h_cap: Elliptic curve point selected uniformly at random from G2\n        u: Elliptic curve point selected uniformly at random from G2\n        pk: Public key in G1 for the issuer with respect to this accumulator, computed as g^sk (in multiplicative notation), where sk is from r_key above\n        y: Elliptic curve point in G2. computed as h_cap^x (in multiplicative notation), where x is from r_key above\n    \"\"\"\n\n    g: str\n    g_dash: str\n    h: str\n    h0: str\n    h1: str\n    h2: str\n    htilde: str\n    h_cap: str\n    u: str\n    pk: str\n    y: str\n\n    @classmethod\n    def from_json_payload(cls, payload: dict):\n        match payload:\n            case {\n                \"g\": g,\n                \"g_dash\": g_dash,\n                \"h\": h,\n                \"h0\": h0,\n                \"h1\": h1,\n                \"h2\": h2,\n                \"htilde\": htilde,\n                \"h_cap\": h_cap,\n                \"u\": u,\n                \"pk\": pk,\n                \"y\": y,\n            }:\n                return cls(g, g_dash, h, h0, h1, h2, htilde, h_cap, u, pk, y)\n            case _:\n                raise Exception(f\"{cls.__name__} JSON parsing failed: Invalid JSON structure\")\n\n    def get_json_payload(self):\n        return self.__dict__\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.models.HcsRevRegEntryMessage","title":"<code>HcsRevRegEntryMessage</code>  <code>dataclass</code>","text":"<p>               Bases: <code>HcsMessage</code>, <code>AnonCredsRevRegEntry</code></p> <p>HCS message class for submitting revocation registry entries.</p> Source code in <code>hiero_did_sdk_python/anoncreds/models/revocation/revocation_registry_entry.py</code> <pre><code>class HcsRevRegEntryMessage(HcsMessage, AnonCredsRevRegEntry):\n    \"\"\"HCS message class for submitting revocation registry entries.\"\"\"\n\n    def is_valid(self, topic_id: str | None = None) -&gt; bool:\n        return bool(self.value) and bool(self.value.accum)\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.models.RevRegDefValue","title":"<code>RevRegDefValue</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>Model representing revocation registry definition value.</p> <p>Attributes:</p> Name Type Description <code>public_keys</code> <code>dict</code> <p>Revocation registry public keys</p> <code>max_cred_num</code> <code>int</code> <p>Max number of credentials which revocation state can be tracked in the registry</p> <code>tails_location</code> <code>str</code> <p>Registry tails file location</p> <code>tails_hash</code> <code>str</code> <p>Registry tails file hash</p> Source code in <code>hiero_did_sdk_python/anoncreds/models/revocation/revocation_registry_definition.py</code> <pre><code>@dataclass\nclass RevRegDefValue(Serializable):\n    \"\"\"Model representing revocation registry definition value.\n\n    Attributes:\n        public_keys: Revocation registry public keys\n        max_cred_num: Max number of credentials which revocation state can be tracked in the registry\n        tails_location: Registry tails file location\n        tails_hash: Registry tails file hash\n    \"\"\"\n\n    public_keys: dict\n    max_cred_num: int\n    tails_location: str\n    tails_hash: str\n\n    @classmethod\n    def from_json_payload(cls, payload: dict):\n        match payload:\n            case {\n                \"publicKeys\": public_keys,\n                \"maxCredNum\": max_cred_num,\n                \"tailsLocation\": tails_location,\n                \"tailsHash\": tails_hash,\n            }:\n                return cls(public_keys, max_cred_num, tails_location, tails_hash)\n            case _:\n                raise Exception(f\"{cls.__name__} JSON parsing failed: Invalid JSON structure\")\n\n    def get_json_payload(self):\n        return {\n            \"publicKeys\": self.public_keys,\n            \"maxCredNum\": self.max_cred_num,\n            \"tailsLocation\": self.tails_location,\n            \"tailsHash\": self.tails_hash,\n        }\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.models.RevRegDefWithHcsMetadata","title":"<code>RevRegDefWithHcsMetadata</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>HCS specific model used to publish registry definition model along with HCS metadata.</p> Source code in <code>hiero_did_sdk_python/anoncreds/models/revocation/revocation_registry_definition.py</code> <pre><code>@dataclass(frozen=True)\nclass RevRegDefWithHcsMetadata(Serializable):\n    \"\"\"HCS specific model used to publish registry definition model along with HCS metadata.\"\"\"\n\n    rev_reg_def: AnonCredsRevRegDef\n    hcs_metadata: RevRegDefHcsMetadata\n\n    @classmethod\n    def from_json_payload(cls, payload: dict):\n        match payload:\n            case {\"revRegDef\": rev_reg_def, \"hcsMetadata\": hcs_metadata}:\n                return cls(rev_reg_def=AnonCredsRevRegDef.from_json_payload(rev_reg_def), hcs_metadata=hcs_metadata)\n            case _:\n                raise Exception(f\"{cls.__name__} JSON parsing failed: Invalid JSON structure\")\n\n    def get_json_payload(self):\n        return {\n            \"revRegDef\": self.rev_reg_def.get_json_payload(),\n            \"hcsMetadata\": self.hcs_metadata,\n        }\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.models.RevRegEntryValue","title":"<code>RevRegEntryValue</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>Model representing revocation registry entry value.</p> <p>Attributes:</p> Name Type Description <code>accum</code> <code>str</code> <p>Current CL accumulator value</p> <code>prev_accum</code> <code>str | None</code> <p>Previous CL accumulator value</p> <code>issued</code> <code>list[int] | None</code> <p>List of issued credential indexes</p> <code>revoked</code> <code>list[int] | None</code> <p>List of revoked credential indexes</p> Source code in <code>hiero_did_sdk_python/anoncreds/models/revocation/revocation_registry_entry.py</code> <pre><code>@dataclass\nclass RevRegEntryValue(Serializable):\n    \"\"\"Model representing revocation registry entry value.\n\n    Attributes:\n        accum: Current CL accumulator value\n        prev_accum: Previous CL accumulator value\n        issued: List of issued credential indexes\n        revoked: List of revoked credential indexes\n    \"\"\"\n\n    accum: str\n    prev_accum: str | None = None\n    issued: list[int] | None = None\n    revoked: list[int] | None = None\n\n    @classmethod\n    def from_json_payload(cls, payload: dict):\n        match payload:\n            case {\"accum\": accum, **rest}:\n                return cls(\n                    accum=accum,\n                    prev_accum=rest.get(\"prevAccum\"),\n                    issued=rest.get(\"issued\"),\n                    revoked=rest.get(\"revoked\"),\n                )\n            case _:\n                raise Exception(f\"{cls.__name__} JSON parsing failed: Invalid JSON structure\")\n\n    def get_json_payload(self):\n        payload: dict = {\"accum\": self.accum}\n\n        if self.prev_accum:\n            payload[\"prevAccum\"] = self.prev_accum\n\n        if self.issued:\n            payload[\"issued\"] = self.issued\n\n        if self.revoked:\n            payload[\"revoked\"] = self.revoked\n\n        return payload\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.types.CredDefState","title":"<code>CredDefState</code>  <code>dataclass</code>","text":"<p>Credential definition state model.</p> <p>Attributes:</p> Name Type Description <code>state</code> <code>ObjectState</code> <p>Object state</p> <code>credential_definition</code> <code>AnonCredsCredDef</code> <p>Credential definition object</p> <code>credential_definition_id</code> <code>str | None</code> <p>Credential definition ID</p> <code>reason</code> <code>str | None</code> <p>Reason (relevant for operation failures)</p> Source code in <code>hiero_did_sdk_python/anoncreds/types.py</code> <pre><code>@dataclass(frozen=True)\nclass CredDefState:\n    \"\"\"Credential definition state model.\n\n    Attributes:\n        state: Object state\n        credential_definition: Credential definition object\n        credential_definition_id: Credential definition ID\n        reason: Reason (relevant for operation failures)\n    \"\"\"\n\n    state: ObjectState\n    credential_definition: AnonCredsCredDef\n    credential_definition_id: str | None = None\n    reason: str | None = None\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.types.GetCredDefResult","title":"<code>GetCredDefResult</code>  <code>dataclass</code>","text":"<p>Credential definition resolution result model.</p> <p>Attributes:</p> Name Type Description <code>credential_definition_id</code> <code>str</code> <p>Credential definition ID</p> <code>resolution_metadata</code> <code>dict</code> <p>Resolution metadata</p> <code>credential_definition_metadata</code> <code>dict</code> <p>Credential definition object metadata</p> <code>credential_definition</code> <code>AnonCredsCredDef | None</code> <p>Credential definition object (empty if resolution is not successful)</p> Source code in <code>hiero_did_sdk_python/anoncreds/types.py</code> <pre><code>@dataclass(frozen=True)\nclass GetCredDefResult:\n    \"\"\"Credential definition resolution result model.\n\n    Attributes:\n        credential_definition_id: Credential definition ID\n        resolution_metadata: Resolution metadata\n        credential_definition_metadata: Credential definition object metadata\n        credential_definition: Credential definition object (empty if resolution is not successful)\n    \"\"\"\n\n    credential_definition_id: str\n    resolution_metadata: dict\n    credential_definition_metadata: dict\n    credential_definition: AnonCredsCredDef | None = None\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.types.GetRevListResult","title":"<code>GetRevListResult</code>  <code>dataclass</code>","text":"<p>Revocation list resolution result model.</p> <p>Attributes:</p> Name Type Description <code>revocation_registry_id</code> <code>str</code> <p>Revocation list ID</p> <code>resolution_metadata</code> <code>dict</code> <p>Resolution metadata</p> <code>revocation_list_metadata</code> <code>dict</code> <p>Revocation list object metadata</p> <code>revocation_list</code> <code>AnonCredsRevList | None</code> <p>Revocation list object (empty if resolution is not successful)</p> Source code in <code>hiero_did_sdk_python/anoncreds/types.py</code> <pre><code>@dataclass(frozen=True)\nclass GetRevListResult:\n    \"\"\"Revocation list resolution result model.\n\n    Attributes:\n        revocation_registry_id: Revocation list ID\n        resolution_metadata: Resolution metadata\n        revocation_list_metadata: Revocation list object metadata\n        revocation_list: Revocation list object (empty if resolution is not successful)\n    \"\"\"\n\n    revocation_registry_id: str\n    resolution_metadata: dict\n    revocation_list_metadata: dict\n    revocation_list: AnonCredsRevList | None = None\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.types.GetRevRegDefResult","title":"<code>GetRevRegDefResult</code>  <code>dataclass</code>","text":"<p>Revocation registry definition resolution result model.</p> <p>Attributes:</p> Name Type Description <code>revocation_registry_definition_id</code> <code>str</code> <p>Revocation registry definition ID</p> <code>resolution_metadata</code> <code>dict</code> <p>Resolution metadata</p> <code>revocation_registry_definition_metadata</code> <code>dict</code> <p>Revocation registry definition object metadata</p> <code>revocation_registry_definition</code> <code>AnonCredsRevRegDef | None</code> <p>Revocation registry definition object (empty if resolution is not successful)</p> Source code in <code>hiero_did_sdk_python/anoncreds/types.py</code> <pre><code>@dataclass(frozen=True)\nclass GetRevRegDefResult:\n    \"\"\"Revocation registry definition resolution result model.\n\n    Attributes:\n        revocation_registry_definition_id: Revocation registry definition ID\n        resolution_metadata: Resolution metadata\n        revocation_registry_definition_metadata: Revocation registry definition object metadata\n        revocation_registry_definition: Revocation registry definition object (empty if resolution is not successful)\n    \"\"\"\n\n    revocation_registry_definition_id: str\n    resolution_metadata: dict\n    revocation_registry_definition_metadata: dict\n    revocation_registry_definition: AnonCredsRevRegDef | None = None\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.types.GetSchemaResult","title":"<code>GetSchemaResult</code>  <code>dataclass</code>","text":"<p>Schema resolution result model.</p> <p>Attributes:</p> Name Type Description <code>schema_id</code> <code>str</code> <p>Schema ID</p> <code>resolution_metadata</code> <code>dict</code> <p>Resolution metadata</p> <code>schema_metadata</code> <code>dict</code> <p>Schema object metadata</p> <code>schema</code> <code>AnonCredsSchema | None</code> <p>Schema object (empty if resolution is not successful)</p> Source code in <code>hiero_did_sdk_python/anoncreds/types.py</code> <pre><code>@dataclass(frozen=True)\nclass GetSchemaResult:\n    \"\"\"Schema resolution result model.\n\n    Attributes:\n        schema_id: Schema ID\n        resolution_metadata: Resolution metadata\n        schema_metadata: Schema object metadata\n        schema: Schema object (empty if resolution is not successful)\n    \"\"\"\n\n    schema_id: str\n    resolution_metadata: dict\n    schema_metadata: dict\n    schema: AnonCredsSchema | None = None\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.types.RegisterCredDefResult","title":"<code>RegisterCredDefResult</code>  <code>dataclass</code>","text":"<p>Credential definition registration result model.</p> <p>Attributes:</p> Name Type Description <code>credential_definition_state</code> <code>CredDefState</code> <p>Credential definition Object state</p> <code>registration_metadata</code> <code>dict</code> <p>Registration metadata</p> <code>credential_definition_metadata</code> <code>dict</code> <p>Credential definition object metadata</p> Source code in <code>hiero_did_sdk_python/anoncreds/types.py</code> <pre><code>@dataclass(frozen=True)\nclass RegisterCredDefResult:\n    \"\"\"Credential definition registration result model.\n\n    Attributes:\n        credential_definition_state: Credential definition Object state\n        registration_metadata: Registration metadata\n        credential_definition_metadata: Credential definition object metadata\n    \"\"\"\n\n    credential_definition_state: CredDefState\n    registration_metadata: dict\n    credential_definition_metadata: dict\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.types.RegisterRevListResult","title":"<code>RegisterRevListResult</code>  <code>dataclass</code>","text":"<p>Revocation list registration result model.</p> <p>Attributes:</p> Name Type Description <code>revocation_list_state</code> <code>RevListState</code> <p>Revocation list Object state</p> <code>registration_metadata</code> <code>dict</code> <p>Registration metadata</p> <code>revocation_list_metadata</code> <code>dict</code> <p>Revocation list object metadata</p> Source code in <code>hiero_did_sdk_python/anoncreds/types.py</code> <pre><code>@dataclass(frozen=True)\nclass RegisterRevListResult:\n    \"\"\"Revocation list registration result model.\n\n    Attributes:\n        revocation_list_state: Revocation list Object state\n        registration_metadata: Registration metadata\n        revocation_list_metadata: Revocation list object metadata\n    \"\"\"\n\n    revocation_list_state: RevListState\n    registration_metadata: dict\n    revocation_list_metadata: dict\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.types.RegisterRevRegDefResult","title":"<code>RegisterRevRegDefResult</code>  <code>dataclass</code>","text":"<p>Revocation registry definition registration result model.</p> <p>Attributes:</p> Name Type Description <code>revocation_registry_definition_state</code> <code>RevRegDefState</code> <p>Revocation registry definition Object state</p> <code>registration_metadata</code> <code>dict</code> <p>Registration metadata</p> <code>revocation_registry_definition_metadata</code> <code>dict</code> <p>Revocation registry definition object metadata</p> Source code in <code>hiero_did_sdk_python/anoncreds/types.py</code> <pre><code>@dataclass(frozen=True)\nclass RegisterRevRegDefResult:\n    \"\"\"Revocation registry definition registration result model.\n\n    Attributes:\n        revocation_registry_definition_state: Revocation registry definition Object state\n        registration_metadata: Registration metadata\n        revocation_registry_definition_metadata: Revocation registry definition object metadata\n    \"\"\"\n\n    revocation_registry_definition_state: RevRegDefState\n    registration_metadata: dict\n    revocation_registry_definition_metadata: dict\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.types.RegisterSchemaResult","title":"<code>RegisterSchemaResult</code>  <code>dataclass</code>","text":"<p>Schema registration result model.</p> <p>Attributes:</p> Name Type Description <code>schema_state</code> <code>SchemaState</code> <p>Schema Object state</p> <code>registration_metadata</code> <code>dict</code> <p>Registration metadata</p> <code>schema_metadata</code> <code>dict</code> <p>Schema object metadata</p> Source code in <code>hiero_did_sdk_python/anoncreds/types.py</code> <pre><code>@dataclass(frozen=True)\nclass RegisterSchemaResult:\n    \"\"\"Schema registration result model.\n\n    Attributes:\n        schema_state: Schema Object state\n        registration_metadata: Registration metadata\n        schema_metadata: Schema object metadata\n    \"\"\"\n\n    schema_state: SchemaState\n    registration_metadata: dict\n    schema_metadata: dict\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.types.RevListState","title":"<code>RevListState</code>  <code>dataclass</code>","text":"<p>Revocation list state model.</p> <p>Attributes:</p> Name Type Description <code>state</code> <code>ObjectState</code> <p>Object state</p> <code>revocation_list</code> <code>AnonCredsRevList</code> <p>Revocation list object</p> <code>reason</code> <code>str | None</code> <p>Reason (relevant for operation failures)</p> Source code in <code>hiero_did_sdk_python/anoncreds/types.py</code> <pre><code>@dataclass(frozen=True)\nclass RevListState:\n    \"\"\"Revocation list state model.\n\n    Attributes:\n        state: Object state\n        revocation_list: Revocation list object\n        reason: Reason (relevant for operation failures)\n    \"\"\"\n\n    state: ObjectState\n    revocation_list: AnonCredsRevList\n    reason: str | None = None\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.types.RevRegDefState","title":"<code>RevRegDefState</code>  <code>dataclass</code>","text":"<p>Revocation registry definition state model.</p> <p>Attributes:</p> Name Type Description <code>state</code> <code>ObjectState</code> <p>Object state</p> <code>revocation_registry_definition</code> <code>AnonCredsRevRegDef</code> <p>Revocation registry definition object</p> <code>revocation_registry_definition_id</code> <code>str | None</code> <p>Revocation registry definition ID</p> <code>reason</code> <code>str | None</code> <p>Reason (relevant for operation failures)</p> Source code in <code>hiero_did_sdk_python/anoncreds/types.py</code> <pre><code>@dataclass(frozen=True)\nclass RevRegDefState:\n    \"\"\"Revocation registry definition state model.\n\n    Attributes:\n        state: Object state\n        revocation_registry_definition: Revocation registry definition object\n        revocation_registry_definition_id: Revocation registry definition ID\n        reason: Reason (relevant for operation failures)\n    \"\"\"\n\n    state: ObjectState\n    revocation_registry_definition: AnonCredsRevRegDef\n    revocation_registry_definition_id: str | None = None\n    reason: str | None = None\n</code></pre>"},{"location":"modules/anoncreds/#hiero_did_sdk_python.anoncreds.types.SchemaState","title":"<code>SchemaState</code>  <code>dataclass</code>","text":"<p>Schema state model.</p> <p>Attributes:</p> Name Type Description <code>state</code> <code>ObjectState</code> <p>Object state</p> <code>schema</code> <code>AnonCredsSchema</code> <p>Schema object</p> <code>schema_id</code> <code>str | None</code> <p>Schema ID</p> <code>reason</code> <code>str | None</code> <p>Reason (relevant for operation failures)</p> Source code in <code>hiero_did_sdk_python/anoncreds/types.py</code> <pre><code>@dataclass(frozen=True)\nclass SchemaState:\n    \"\"\"Schema state model.\n\n    Attributes:\n        state: Object state\n        schema: Schema object\n        schema_id: Schema ID\n        reason: Reason (relevant for operation failures)\n    \"\"\"\n\n    state: ObjectState\n    schema: AnonCredsSchema\n    schema_id: str | None = None\n    reason: str | None = None\n</code></pre>"},{"location":"modules/common/","title":"Common module","text":"<p>Common classes/utils included in SDK public API.</p>"},{"location":"modules/common/#caching","title":"Caching","text":""},{"location":"modules/common/#hiero_did_sdk_python.utils.cache.Cache","title":"<code>Cache</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Interface for cache instances used across SDK. Can be used to create custom cache implementations.</p> Source code in <code>hiero_did_sdk_python/utils/cache.py</code> <pre><code>class Cache[K, V](ABC):\n    \"\"\"Interface for cache instances used across SDK. Can be used to create custom cache implementations.\"\"\"\n\n    def __init__(self):\n        self._locks = {}\n\n    def _get_lock(self, key: K) -&gt; Lock:\n        if key not in self._locks:\n            self._locks[key] = Lock()\n\n        return self._locks[key]\n\n    @final\n    def get(self, key: K) -&gt; V | None:\n        \"\"\"Get cached data by key\n\n        Args:\n            key: Cached data key\n\n        Returns:\n            object: Cached data\n        \"\"\"\n\n        lock = self._get_lock(key)\n\n        with lock:\n            return self.data_get(key)\n\n    @final\n    def set(self, key: K, value: V, ttl: seconds | None = None) -&gt; None:\n        \"\"\"Set cached data with key\n\n        Args:\n            key: Data key\n            value: Data to cache\n            ttl: Data retention duration in seconds.\n        \"\"\"\n        ttl = ttl or DEFAULT_TTL\n\n        lock = self._get_lock(key)\n\n        with lock:\n            self.data_set(key, value, ttl)\n\n    @final\n    def remove(self, key: K) -&gt; None:\n        \"\"\"Remove cached data by key.\n\n        Args:\n            key: Cached data key\n        \"\"\"\n        lock = self._get_lock(key)\n\n        with lock:\n            self.data_remove(key)\n\n    @final\n    def size(self):\n        \"\"\"Get cached records count.\"\"\"\n        return self.data_size()\n\n    @final\n    def flush(self):\n        \"\"\"Clear cached data.\"\"\"\n        return self.data_flush()\n\n    @abstractmethod\n    def data_get(self, key: K) -&gt; V | None:\n        pass\n\n    @abstractmethod\n    def data_set(self, key: K, value: V, ttl):\n        pass\n\n    @abstractmethod\n    def data_remove(self, key: K):\n        pass\n\n    @abstractmethod\n    def data_size(self) -&gt; int:\n        pass\n\n    @abstractmethod\n    def data_flush(self):\n        pass\n</code></pre>"},{"location":"modules/common/#hiero_did_sdk_python.utils.cache.Cache.flush","title":"<code>flush()</code>","text":"<p>Clear cached data.</p> Source code in <code>hiero_did_sdk_python/utils/cache.py</code> <pre><code>@final\ndef flush(self):\n    \"\"\"Clear cached data.\"\"\"\n    return self.data_flush()\n</code></pre>"},{"location":"modules/common/#hiero_did_sdk_python.utils.cache.Cache.get","title":"<code>get(key)</code>","text":"<p>Get cached data by key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Cache[K]</code> <p>Cached data key</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>Cache[V] | None</code> <p>Cached data</p> Source code in <code>hiero_did_sdk_python/utils/cache.py</code> <pre><code>@final\ndef get(self, key: K) -&gt; V | None:\n    \"\"\"Get cached data by key\n\n    Args:\n        key: Cached data key\n\n    Returns:\n        object: Cached data\n    \"\"\"\n\n    lock = self._get_lock(key)\n\n    with lock:\n        return self.data_get(key)\n</code></pre>"},{"location":"modules/common/#hiero_did_sdk_python.utils.cache.Cache.remove","title":"<code>remove(key)</code>","text":"<p>Remove cached data by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Cache[K]</code> <p>Cached data key</p> required Source code in <code>hiero_did_sdk_python/utils/cache.py</code> <pre><code>@final\ndef remove(self, key: K) -&gt; None:\n    \"\"\"Remove cached data by key.\n\n    Args:\n        key: Cached data key\n    \"\"\"\n    lock = self._get_lock(key)\n\n    with lock:\n        self.data_remove(key)\n</code></pre>"},{"location":"modules/common/#hiero_did_sdk_python.utils.cache.Cache.set","title":"<code>set(key, value, ttl=None)</code>","text":"<p>Set cached data with key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Cache[K]</code> <p>Data key</p> required <code>value</code> <code>Cache[V]</code> <p>Data to cache</p> required <code>ttl</code> <code>seconds | None</code> <p>Data retention duration in seconds.</p> <code>None</code> Source code in <code>hiero_did_sdk_python/utils/cache.py</code> <pre><code>@final\ndef set(self, key: K, value: V, ttl: seconds | None = None) -&gt; None:\n    \"\"\"Set cached data with key\n\n    Args:\n        key: Data key\n        value: Data to cache\n        ttl: Data retention duration in seconds.\n    \"\"\"\n    ttl = ttl or DEFAULT_TTL\n\n    lock = self._get_lock(key)\n\n    with lock:\n        self.data_set(key, value, ttl)\n</code></pre>"},{"location":"modules/common/#hiero_did_sdk_python.utils.cache.Cache.size","title":"<code>size()</code>","text":"<p>Get cached records count.</p> Source code in <code>hiero_did_sdk_python/utils/cache.py</code> <pre><code>@final\ndef size(self):\n    \"\"\"Get cached records count.\"\"\"\n    return self.data_size()\n</code></pre>"},{"location":"modules/common/#hiero_did_sdk_python.utils.cache.MemoryCache","title":"<code>MemoryCache</code>","text":"<p>               Bases: <code>Cache[MemoryCache[K], MemoryCache[V]]</code></p> <p>In-memory cache implementation. Includes built-in data retention logic.</p> Source code in <code>hiero_did_sdk_python/utils/cache.py</code> <pre><code>class MemoryCache[K, V](Cache[K, V]):\n    \"\"\"In-memory cache implementation. Includes built-in data retention logic.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._mem: dict[K, TimestampedRecord[V]] = {}\n\n    # Cache clearing logic goes to child class because different classes can use different strategies\n    # For example, Redis would use its built-in key TTL mechanic\n    def _remove_expired_cached_items(self):\n        for key in self._mem.copy():\n            value = self._mem.get(key, None)\n\n            # Assure value is still there, in multithreaded environment\n            if value is not None:\n                expires_timestamp = value.timestamp\n                now = time.time()\n\n                if now &gt; expires_timestamp:\n                    self.data_remove(key)\n\n    @override\n    def data_get(self, key: K) -&gt; V | None:\n        self._remove_expired_cached_items()\n\n        record = self._mem.get(key, None)\n\n        if record is None:\n            return None\n\n        return record.data\n\n    @override\n    def data_set(self, key: K, value: V, ttl: seconds):\n        self._remove_expired_cached_items()\n\n        expires_timestamp = time.time() + ttl\n        self._mem[key] = TimestampedRecord(value, expires_timestamp)\n\n    @override\n    def data_size(self):\n        return len(self._mem)\n\n    @override\n    def data_remove(self, key):\n        # del wouldn't be thread safe\n        self._mem.pop(key, None)\n\n    @override\n    def data_flush(self):\n        self._mem = {}\n</code></pre>"},{"location":"modules/common/#hiero_did_sdk_python.utils.cache.TimestampedRecord","title":"<code>TimestampedRecord</code>  <code>dataclass</code>","text":"<p>Helper model for timestamped records.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>TimestampedRecord[T]</code> <p>Record data (generic)</p> <code>timestamp</code> <code>float</code> <p>Timestamp of record creation</p> Source code in <code>hiero_did_sdk_python/utils/cache.py</code> <pre><code>@dataclass\nclass TimestampedRecord[T]:\n    \"\"\"Helper model for timestamped records.\n\n    Attributes:\n        data: Record data (generic)\n        timestamp: Timestamp of record creation\n    \"\"\"\n\n    data: T\n    timestamp: float = field(default_factory=time.time)\n</code></pre>"},{"location":"modules/common/#helper-classes-and-utils","title":"Helper classes and utils","text":""},{"location":"modules/common/#hiero_did_sdk_python.utils.serializable.Serializable","title":"<code>Serializable</code>","text":"Source code in <code>hiero_did_sdk_python/utils/serializable.py</code> <pre><code>class Serializable:\n    @classmethod\n    def from_json(\n        cls,\n        json_str: str,\n    ) -&gt; Self:\n        \"\"\"Parse a JSON string into an object instance.\n\n        Args:\n            json_str: JSON string\n\n        Returns:\n            An instance representation of this JSON\n\n        \"\"\"\n        try:\n            return cls.from_json_payload(json.loads(json_str))\n        except ValueError as e:\n            raise Exception(f\"{cls.__name__} JSON parsing failed: Invalid JSON structure\") from e\n\n    @classmethod\n    @abstractmethod\n    def from_json_payload(cls, payload: dict) -&gt; Self:\n        \"\"\"Create object instance from parsed JSON payload.\n\n        Args:\n            payload: parsed JSON dictionary\n\n        Returns:\n            Object instance\n\n        \"\"\"\n\n    def to_json(self) -&gt; str:\n        \"\"\"Create JSON string of object payload.\n\n        Returns:\n            A JSON representation of this message\n\n        \"\"\"\n        return json.dumps(self.get_json_payload(), separators=(\",\", \":\"))\n\n    @abstractmethod\n    def get_json_payload(self) -&gt; dict:\n        \"\"\"Get object payload for JSON representation\"\"\"\n</code></pre>"},{"location":"modules/common/#hiero_did_sdk_python.utils.serializable.Serializable.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Parse a JSON string into an object instance.</p> <p>Parameters:</p> Name Type Description Default <code>json_str</code> <code>str</code> <p>JSON string</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An instance representation of this JSON</p> Source code in <code>hiero_did_sdk_python/utils/serializable.py</code> <pre><code>@classmethod\ndef from_json(\n    cls,\n    json_str: str,\n) -&gt; Self:\n    \"\"\"Parse a JSON string into an object instance.\n\n    Args:\n        json_str: JSON string\n\n    Returns:\n        An instance representation of this JSON\n\n    \"\"\"\n    try:\n        return cls.from_json_payload(json.loads(json_str))\n    except ValueError as e:\n        raise Exception(f\"{cls.__name__} JSON parsing failed: Invalid JSON structure\") from e\n</code></pre>"},{"location":"modules/common/#hiero_did_sdk_python.utils.serializable.Serializable.from_json_payload","title":"<code>from_json_payload(payload)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Create object instance from parsed JSON payload.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>parsed JSON dictionary</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Object instance</p> Source code in <code>hiero_did_sdk_python/utils/serializable.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_json_payload(cls, payload: dict) -&gt; Self:\n    \"\"\"Create object instance from parsed JSON payload.\n\n    Args:\n        payload: parsed JSON dictionary\n\n    Returns:\n        Object instance\n\n    \"\"\"\n</code></pre>"},{"location":"modules/common/#hiero_did_sdk_python.utils.serializable.Serializable.get_json_payload","title":"<code>get_json_payload()</code>  <code>abstractmethod</code>","text":"<p>Get object payload for JSON representation</p> Source code in <code>hiero_did_sdk_python/utils/serializable.py</code> <pre><code>@abstractmethod\ndef get_json_payload(self) -&gt; dict:\n    \"\"\"Get object payload for JSON representation\"\"\"\n</code></pre>"},{"location":"modules/common/#hiero_did_sdk_python.utils.serializable.Serializable.to_json","title":"<code>to_json()</code>","text":"<p>Create JSON string of object payload.</p> <p>Returns:</p> Type Description <code>str</code> <p>A JSON representation of this message</p> Source code in <code>hiero_did_sdk_python/utils/serializable.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Create JSON string of object payload.\n\n    Returns:\n        A JSON representation of this message\n\n    \"\"\"\n    return json.dumps(self.get_json_payload(), separators=(\",\", \":\"))\n</code></pre>"},{"location":"modules/did/","title":"Hedera DID module","text":"<p>This module provides API for Hedera DID management.</p> <p>Based on latest Hedera DID spec.</p>"},{"location":"modules/did/#did-resolver","title":"DID resolver","text":""},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did_resolver.HederaDidResolver","title":"<code>HederaDidResolver</code>","text":"<p>Hedera DID Resolver implementation.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>Hedera Client</p> required <code>cache_instance</code> <code>Cache[str, TimestampedRecord[DidDocument]] | None</code> <p>Custom cache instance. If not provided, in-memory cache is used</p> <code>None</code> Source code in <code>hiero_did_sdk_python/did/hedera_did_resolver.py</code> <pre><code>class HederaDidResolver:\n    \"\"\"Hedera DID Resolver implementation.\n\n    Args:\n        client: Hedera Client\n        cache_instance: Custom cache instance. If not provided, in-memory cache is used\n    \"\"\"\n\n    def __init__(\n        self,\n        client: Client,\n        cache_instance: Cache[str, TimestampedRecord[DidDocument]] | None = None,\n    ):\n        self._client = client\n        self._cache = cache_instance or MemoryCache[str, TimestampedRecord[DidDocument]]()\n\n    async def resolve(self, did: str) -&gt; DIDResolutionResult:\n        \"\"\"\n        Resolve DID document by identifier.\n\n        Args:\n            did: DID identifier to resolve\n\n        Returns:\n            object: DID resolution result\n        \"\"\"\n        try:\n            parsed_identifier = parse_identifier(did)\n            topic_id = parsed_identifier.topic_id\n\n            timestamped_record: TimestampedRecord | None = self._cache.get(topic_id)\n\n            if timestamped_record:\n                now = time.time()\n                last_updated_timestamp: float = timestamped_record.timestamp\n                did_document: DidDocument = timestamped_record.data\n\n                if (now - last_updated_timestamp) &gt; INSERTION_THRESHOLD_SECONDS:\n                    result = await HcsMessageResolver(\n                        topic_id,\n                        HcsDidMessageEnvelope,\n                        timestamp_from=Timestamp(int(last_updated_timestamp), 0),\n                    ).execute(self._client)\n\n                    await did_document.process_messages(cast(list[HcsDidMessageEnvelope], result))\n\n                    self._cache.set(\n                        topic_id,\n                        TimestampedRecord(\n                            did_document,\n                            did_document.version_timestamp.timestamp()\n                            if did_document.version_timestamp\n                            else time.time(),\n                        ),\n                    )\n            else:\n                registered_did = HederaDid(identifier=did, client=self._client)\n\n                did_document = await registered_did.resolve()\n\n                self._cache.set(\n                    topic_id,\n                    TimestampedRecord(\n                        did_document,\n                        did_document.version_timestamp.timestamp() if did_document.version_timestamp else time.time(),\n                    ),\n                )\n\n            document_meta: dict = {\"deactivated\": did_document.deactivated}\n\n            if not did_document.deactivated:\n                document_meta.update({\n                    \"created\": did_document.created.isoformat().replace(\"+00:00\", \"Z\")\n                    if did_document.created\n                    else None,\n                    \"updated\": did_document.updated.isoformat().replace(\"+00:00\", \"Z\")\n                    if did_document.updated\n                    else None,\n                })\n\n            return {\n                \"didDocumentMetadata\": cast(DIDDocumentMetadata, document_meta),\n                \"didResolutionMetadata\": {\"contentType\": \"application/did+ld+json\"},\n                \"didDocument\": cast(DIDDocument, did_document.get_json_payload()),\n            }\n        except Exception as error:\n            return {\n                \"didResolutionMetadata\": {\n                    \"error\": _get_error_description(error),\n                    \"message\": str(error),  # pyright: ignore - this is not in spec, but may be helpful\n                },\n                \"didDocumentMetadata\": {},\n                \"didDocument\": None,\n            }\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did_resolver.HederaDidResolver.resolve","title":"<code>resolve(did)</code>  <code>async</code>","text":"<p>Resolve DID document by identifier.</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>DID identifier to resolve</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>DIDResolutionResult</code> <p>DID resolution result</p> Source code in <code>hiero_did_sdk_python/did/hedera_did_resolver.py</code> <pre><code>async def resolve(self, did: str) -&gt; DIDResolutionResult:\n    \"\"\"\n    Resolve DID document by identifier.\n\n    Args:\n        did: DID identifier to resolve\n\n    Returns:\n        object: DID resolution result\n    \"\"\"\n    try:\n        parsed_identifier = parse_identifier(did)\n        topic_id = parsed_identifier.topic_id\n\n        timestamped_record: TimestampedRecord | None = self._cache.get(topic_id)\n\n        if timestamped_record:\n            now = time.time()\n            last_updated_timestamp: float = timestamped_record.timestamp\n            did_document: DidDocument = timestamped_record.data\n\n            if (now - last_updated_timestamp) &gt; INSERTION_THRESHOLD_SECONDS:\n                result = await HcsMessageResolver(\n                    topic_id,\n                    HcsDidMessageEnvelope,\n                    timestamp_from=Timestamp(int(last_updated_timestamp), 0),\n                ).execute(self._client)\n\n                await did_document.process_messages(cast(list[HcsDidMessageEnvelope], result))\n\n                self._cache.set(\n                    topic_id,\n                    TimestampedRecord(\n                        did_document,\n                        did_document.version_timestamp.timestamp()\n                        if did_document.version_timestamp\n                        else time.time(),\n                    ),\n                )\n        else:\n            registered_did = HederaDid(identifier=did, client=self._client)\n\n            did_document = await registered_did.resolve()\n\n            self._cache.set(\n                topic_id,\n                TimestampedRecord(\n                    did_document,\n                    did_document.version_timestamp.timestamp() if did_document.version_timestamp else time.time(),\n                ),\n            )\n\n        document_meta: dict = {\"deactivated\": did_document.deactivated}\n\n        if not did_document.deactivated:\n            document_meta.update({\n                \"created\": did_document.created.isoformat().replace(\"+00:00\", \"Z\")\n                if did_document.created\n                else None,\n                \"updated\": did_document.updated.isoformat().replace(\"+00:00\", \"Z\")\n                if did_document.updated\n                else None,\n            })\n\n        return {\n            \"didDocumentMetadata\": cast(DIDDocumentMetadata, document_meta),\n            \"didResolutionMetadata\": {\"contentType\": \"application/did+ld+json\"},\n            \"didDocument\": cast(DIDDocument, did_document.get_json_payload()),\n        }\n    except Exception as error:\n        return {\n            \"didResolutionMetadata\": {\n                \"error\": _get_error_description(error),\n                \"message\": str(error),  # pyright: ignore - this is not in spec, but may be helpful\n            },\n            \"didDocumentMetadata\": {},\n            \"didDocument\": None,\n        }\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did_resolver.DidResolutionError","title":"<code>DidResolutionError</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum for DID resolution errors</p> Source code in <code>hiero_did_sdk_python/did/hedera_did_resolver.py</code> <pre><code>class DidResolutionError(StrEnum):\n    \"\"\"Enum for DID resolution errors\"\"\"\n\n    \"\"\"\n    The resolver has failed to construct the DID document.\n    This can be caused by a network issue, a wrong registry address or malformed logs while parsing the registry history.\n    Please inspect the `DIDResolutionMetadata.message` to debug further.\n    \"\"\"\n    NOT_FOUND = \"notFound\"\n\n    \"\"\"\n    The resolver does not know how to resolve the given DID. Most likely it is not a `did:hedera`.\n    \"\"\"\n    INVALID_DID = \"invalidDid\"\n\n    \"\"\"\n    The resolver is misconfigured or is being asked to resolve a DID anchored on an unknown network\n    \"\"\"\n    UNKNOWN_NETWORK = \"unknownNetwork\"\n\n    \"\"\"\n    Unknown resolution error\n    \"\"\"\n    UNKNOWN = \"unknown\"\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did_resolver.DidResolutionError.INVALID_DID","title":"<code>INVALID_DID = 'invalidDid'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The resolver is misconfigured or is being asked to resolve a DID anchored on an unknown network</p>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did_resolver.DidResolutionError.NOT_FOUND","title":"<code>NOT_FOUND = 'notFound'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The resolver does not know how to resolve the given DID. Most likely it is not a <code>did:hedera</code>.</p>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did_resolver.DidResolutionError.UNKNOWN_NETWORK","title":"<code>UNKNOWN_NETWORK = 'unknownNetwork'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unknown resolution error</p>"},{"location":"modules/did/#did-management-api","title":"DID management API","text":""},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did.HederaDid","title":"<code>HederaDid</code>","text":"<p>Class representing Hedera DID instance, provides access to DID management API.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>Hedera Client</p> required <code>identifier</code> <code>str | None</code> <p>DID identifier (for existing DIDs)</p> <code>None</code> <code>private_key_der</code> <code>str | None</code> <p>DID Owner (controller) private key encoded in DER format. Can be empty for read-only access</p> <code>None</code> Source code in <code>hiero_did_sdk_python/did/hedera_did.py</code> <pre><code>class HederaDid:\n    \"\"\"\n    Class representing Hedera DID instance, provides access to DID management API.\n\n    Args:\n        client: Hedera Client\n        identifier: DID identifier (for existing DIDs)\n        private_key_der: DID Owner (controller) private key encoded in DER format. Can be empty for read-only access\n    \"\"\"\n\n    def __init__(self, client: Client, identifier: str | None = None, private_key_der: str | None = None):\n        if not identifier and not private_key_der:\n            raise DidException(\"'identifier' and 'private_key_der' cannot both be empty\")\n\n        self._client = client\n        self._hcs_topic_service = HcsTopicService(client)\n\n        self._private_key = PrivateKey.from_string(private_key_der) if private_key_der else None\n        self._key_type: SupportedKeyType | None = (\n            cast(SupportedKeyType, get_key_type(self._private_key)) if self._private_key else None\n        )\n\n        self.identifier = identifier\n        if self.identifier:\n            parsed_identifier = parse_identifier(self.identifier)\n            self.network = parsed_identifier.network\n            self.topic_id = parsed_identifier.topic_id\n        else:\n            self.topic_id = None\n\n        self.document: DidDocument | None = None\n\n    async def register(self):\n        \"\"\"Register (create) DID instance in Hedera network\"\"\"\n        if not self._private_key or not self._key_type:\n            raise DidException(\"Private key is required to register new DID\")\n\n        if self.identifier:\n            document = await self.resolve()\n            if document.controller:\n                raise DidException(\"DID is already registered\")\n        else:\n            topic_options = HcsTopicOptions(\n                admin_key=self._private_key.public_key(), submit_key=self._private_key.public_key()\n            )\n\n            self.topic_id = await self._hcs_topic_service.create_topic(topic_options, [self._private_key])\n\n            self.network = self._client.network.network\n            self.identifier = build_identifier(\n                self.network,\n                multibase_encode(bytes(self._private_key.public_key().to_bytes_raw()), \"base58btc\"),\n                self.topic_id,\n            )\n\n        hcs_event = HcsDidUpdateDidOwnerEvent(\n            id_=self.identifier,\n            controller=self.identifier,\n            public_key=self._private_key.public_key(),\n            type_=self._key_type,\n        )\n\n        await self._submit_transaction(DidDocumentOperation.CREATE, hcs_event)\n\n    async def change_owner(self, controller: str, new_private_key_der: str):\n        \"\"\"\n        Change DID Owner (controller).\n\n        Args:\n            controller: Identifier of new DID Owner\n            new_private_key_der: New DID Owner private key encoded in DER format\n        \"\"\"\n        self._assert_can_submit_transaction()\n\n        document = await self.resolve()\n        if not document.controller:\n            raise DidException(\"DID is not registered or was recently deleted. DID has to be registered first\")\n\n        new_private_key = PrivateKey.from_string(new_private_key_der)\n        new_key_type = get_key_type(new_private_key)\n\n        topic_update_options = HcsTopicOptions(\n            admin_key=new_private_key.public_key(), submit_key=new_private_key.public_key()\n        )\n        await self._hcs_topic_service.update_topic(\n            cast(str, self.topic_id), topic_update_options, [cast(PrivateKey, self._private_key), new_private_key]\n        )\n\n        self._private_key = new_private_key\n        self._key_type = new_key_type\n\n        hcs_event = HcsDidUpdateDidOwnerEvent(\n            id_=cast(str, self.identifier),\n            controller=controller,\n            public_key=self._private_key.public_key(),\n            type_=self._key_type,\n        )\n\n        await self._submit_transaction(DidDocumentOperation.UPDATE, hcs_event)\n\n    async def resolve(self) -&gt; DidDocument:\n        \"\"\"\n        Resolve DID document for registered instance.\n\n        Returns:\n            object: DID document\n        \"\"\"\n        if not self.topic_id or not self.identifier:\n            raise DidException(\"DID is not registered\")\n\n        result = await HcsMessageResolver(self.topic_id, HcsDidMessageEnvelope).execute(self._client)\n        await self._handle_resolution_result(cast(list[HcsDidMessageEnvelope], result))\n\n        return cast(DidDocument, self.document)\n\n    async def delete(self):\n        \"\"\"Delete (deactivate) registered DID instance.\"\"\"\n        self._assert_can_submit_transaction()\n\n        await self._submit_transaction(DidDocumentOperation.DELETE, HcsDidDeleteEvent())\n\n    async def add_or_update_service(self, id_: str, service_type: DidServiceType, service_endpoint: str):\n        \"\"\"Add or update DID document service\n\n        Args:\n            id_: Service ID to create\n            service_type: DID service type\n            service_endpoint: Service endpoint\n        \"\"\"\n        self._assert_can_submit_transaction()\n\n        hcs_event = HcsDidUpdateServiceEvent(id_=id_, type_=service_type, service_endpoint=service_endpoint)\n\n        await self._submit_transaction(DidDocumentOperation.UPDATE, hcs_event)\n\n    async def revoke_service(self, id_: str):\n        \"\"\"Revoke existing DID document service\n\n        Args:\n            id_: Service ID to revoke\n        \"\"\"\n        self._assert_can_submit_transaction()\n\n        hcs_event = HcsDidRevokeServiceEvent(id_)\n        await self._submit_transaction(DidDocumentOperation.REVOKE, hcs_event)\n\n    async def add_or_update_verification_method(\n        self,\n        id_: str,\n        controller: str,\n        public_key_der: str,\n        type_: SupportedKeyType,\n    ):\n        \"\"\"Add or update DID document verification method\n\n        Args:\n            id_: Verification method ID to create\n            controller: Verification method controller ID\n            public_key_der: Verification method public key encoded in DER format\n            type_: Verification method key type\n        \"\"\"\n\n        self._assert_can_submit_transaction()\n\n        hcs_event = HcsDidUpdateVerificationMethodEvent(\n            id_=id_, controller=controller, public_key=PublicKey.from_string(public_key_der), type_=type_\n        )\n\n        await self._submit_transaction(DidDocumentOperation.UPDATE, hcs_event)\n\n    async def revoke_verification_method(self, id_: str):\n        \"\"\"Revoke existing DID document verification method\n\n        Args:\n            id_: Verification method ID to revoke\n        \"\"\"\n        self._assert_can_submit_transaction()\n\n        hcs_event = HcsDidRevokeVerificationMethodEvent(id_)\n        await self._submit_transaction(DidDocumentOperation.REVOKE, hcs_event)\n\n    async def add_or_update_verification_relationship(\n        self,\n        id_: str,\n        controller: str,\n        public_key_der: str,\n        relationship_type: VerificationRelationshipType,\n        type_: SupportedKeyType,\n    ):\n        \"\"\"Add or update DID document verification relationship\n\n        Args:\n            id_: Verification relationship ID to create\n            controller: Verification relationship controller ID\n            public_key_der: Verification relationship public key encoded in DER format\n            relationship_type: Verification relationship type\n            type_: Verification relationship key type\n        \"\"\"\n\n        self._assert_can_submit_transaction()\n\n        hcs_event = HcsDidUpdateVerificationRelationshipEvent(\n            id_=id_,\n            controller=controller,\n            public_key=PublicKey.from_string(public_key_der),\n            relationship_type=relationship_type,\n            type_=type_,\n        )\n\n        await self._submit_transaction(DidDocumentOperation.UPDATE, hcs_event)\n\n    async def revoke_verification_relationship(self, id_: str, relationship_type: VerificationRelationshipType):\n        \"\"\"Revoke existing DID document verification relationship\n\n        Args:\n            id_: Verification relationship ID to revoke\n            relationship_type: Verification relationship type\n        \"\"\"\n        self._assert_can_submit_transaction()\n\n        hcs_event = HcsDidRevokeVerificationRelationshipEvent(id_, relationship_type)\n        await self._submit_transaction(DidDocumentOperation.REVOKE, hcs_event)\n\n    async def _submit_transaction(self, operation: DidDocumentOperation, event: HcsDidEvent):\n        if not self.topic_id or not self.identifier or not self._private_key:\n            raise Exception(\"Cannot submit transaction: topic_id, identifier and private_key must be set\")\n\n        message = HcsDidMessage(operation, self.identifier, event)\n        envelope = HcsDidMessageEnvelope(message)\n        envelope.sign(self._private_key)\n\n        def build_did_transaction(message_submit_transaction: TopicMessageSubmitTransaction) -&gt; Transaction:\n            message_submit_transaction.transaction_fee = MAX_TRANSACTION_FEE.to_tinybars()  # pyright: ignore [reportAttributeAccessIssue]\n            return message_submit_transaction.freeze_with(self._client).sign(self._private_key)\n\n        await HcsMessageTransaction(self.topic_id, envelope, build_did_transaction).execute(self._client)\n\n    async def _handle_resolution_result(self, result: list[HcsDidMessageEnvelope]):\n        if not self.identifier:\n            raise Exception(\"Cannot handle DID resolution result: DID identifier is not defined\")\n\n        self.document = DidDocument(self.identifier)\n        await self.document.process_messages(result)\n\n    def _assert_can_submit_transaction(self):\n        if not self.identifier:\n            raise DidException(\"DID is not registered\")\n\n        if not self._private_key or not self._key_type:\n            raise DidException(\"Private key is required to submit DID event transaction\")\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did.HederaDid.add_or_update_service","title":"<code>add_or_update_service(id_, service_type, service_endpoint)</code>  <code>async</code>","text":"<p>Add or update DID document service</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Service ID to create</p> required <code>service_type</code> <code>DidServiceType</code> <p>DID service type</p> required <code>service_endpoint</code> <code>str</code> <p>Service endpoint</p> required Source code in <code>hiero_did_sdk_python/did/hedera_did.py</code> <pre><code>async def add_or_update_service(self, id_: str, service_type: DidServiceType, service_endpoint: str):\n    \"\"\"Add or update DID document service\n\n    Args:\n        id_: Service ID to create\n        service_type: DID service type\n        service_endpoint: Service endpoint\n    \"\"\"\n    self._assert_can_submit_transaction()\n\n    hcs_event = HcsDidUpdateServiceEvent(id_=id_, type_=service_type, service_endpoint=service_endpoint)\n\n    await self._submit_transaction(DidDocumentOperation.UPDATE, hcs_event)\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did.HederaDid.add_or_update_verification_method","title":"<code>add_or_update_verification_method(id_, controller, public_key_der, type_)</code>  <code>async</code>","text":"<p>Add or update DID document verification method</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Verification method ID to create</p> required <code>controller</code> <code>str</code> <p>Verification method controller ID</p> required <code>public_key_der</code> <code>str</code> <p>Verification method public key encoded in DER format</p> required <code>type_</code> <code>SupportedKeyType</code> <p>Verification method key type</p> required Source code in <code>hiero_did_sdk_python/did/hedera_did.py</code> <pre><code>async def add_or_update_verification_method(\n    self,\n    id_: str,\n    controller: str,\n    public_key_der: str,\n    type_: SupportedKeyType,\n):\n    \"\"\"Add or update DID document verification method\n\n    Args:\n        id_: Verification method ID to create\n        controller: Verification method controller ID\n        public_key_der: Verification method public key encoded in DER format\n        type_: Verification method key type\n    \"\"\"\n\n    self._assert_can_submit_transaction()\n\n    hcs_event = HcsDidUpdateVerificationMethodEvent(\n        id_=id_, controller=controller, public_key=PublicKey.from_string(public_key_der), type_=type_\n    )\n\n    await self._submit_transaction(DidDocumentOperation.UPDATE, hcs_event)\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did.HederaDid.add_or_update_verification_relationship","title":"<code>add_or_update_verification_relationship(id_, controller, public_key_der, relationship_type, type_)</code>  <code>async</code>","text":"<p>Add or update DID document verification relationship</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Verification relationship ID to create</p> required <code>controller</code> <code>str</code> <p>Verification relationship controller ID</p> required <code>public_key_der</code> <code>str</code> <p>Verification relationship public key encoded in DER format</p> required <code>relationship_type</code> <code>VerificationRelationshipType</code> <p>Verification relationship type</p> required <code>type_</code> <code>SupportedKeyType</code> <p>Verification relationship key type</p> required Source code in <code>hiero_did_sdk_python/did/hedera_did.py</code> <pre><code>async def add_or_update_verification_relationship(\n    self,\n    id_: str,\n    controller: str,\n    public_key_der: str,\n    relationship_type: VerificationRelationshipType,\n    type_: SupportedKeyType,\n):\n    \"\"\"Add or update DID document verification relationship\n\n    Args:\n        id_: Verification relationship ID to create\n        controller: Verification relationship controller ID\n        public_key_der: Verification relationship public key encoded in DER format\n        relationship_type: Verification relationship type\n        type_: Verification relationship key type\n    \"\"\"\n\n    self._assert_can_submit_transaction()\n\n    hcs_event = HcsDidUpdateVerificationRelationshipEvent(\n        id_=id_,\n        controller=controller,\n        public_key=PublicKey.from_string(public_key_der),\n        relationship_type=relationship_type,\n        type_=type_,\n    )\n\n    await self._submit_transaction(DidDocumentOperation.UPDATE, hcs_event)\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did.HederaDid.change_owner","title":"<code>change_owner(controller, new_private_key_der)</code>  <code>async</code>","text":"<p>Change DID Owner (controller).</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>str</code> <p>Identifier of new DID Owner</p> required <code>new_private_key_der</code> <code>str</code> <p>New DID Owner private key encoded in DER format</p> required Source code in <code>hiero_did_sdk_python/did/hedera_did.py</code> <pre><code>async def change_owner(self, controller: str, new_private_key_der: str):\n    \"\"\"\n    Change DID Owner (controller).\n\n    Args:\n        controller: Identifier of new DID Owner\n        new_private_key_der: New DID Owner private key encoded in DER format\n    \"\"\"\n    self._assert_can_submit_transaction()\n\n    document = await self.resolve()\n    if not document.controller:\n        raise DidException(\"DID is not registered or was recently deleted. DID has to be registered first\")\n\n    new_private_key = PrivateKey.from_string(new_private_key_der)\n    new_key_type = get_key_type(new_private_key)\n\n    topic_update_options = HcsTopicOptions(\n        admin_key=new_private_key.public_key(), submit_key=new_private_key.public_key()\n    )\n    await self._hcs_topic_service.update_topic(\n        cast(str, self.topic_id), topic_update_options, [cast(PrivateKey, self._private_key), new_private_key]\n    )\n\n    self._private_key = new_private_key\n    self._key_type = new_key_type\n\n    hcs_event = HcsDidUpdateDidOwnerEvent(\n        id_=cast(str, self.identifier),\n        controller=controller,\n        public_key=self._private_key.public_key(),\n        type_=self._key_type,\n    )\n\n    await self._submit_transaction(DidDocumentOperation.UPDATE, hcs_event)\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did.HederaDid.delete","title":"<code>delete()</code>  <code>async</code>","text":"<p>Delete (deactivate) registered DID instance.</p> Source code in <code>hiero_did_sdk_python/did/hedera_did.py</code> <pre><code>async def delete(self):\n    \"\"\"Delete (deactivate) registered DID instance.\"\"\"\n    self._assert_can_submit_transaction()\n\n    await self._submit_transaction(DidDocumentOperation.DELETE, HcsDidDeleteEvent())\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did.HederaDid.register","title":"<code>register()</code>  <code>async</code>","text":"<p>Register (create) DID instance in Hedera network</p> Source code in <code>hiero_did_sdk_python/did/hedera_did.py</code> <pre><code>async def register(self):\n    \"\"\"Register (create) DID instance in Hedera network\"\"\"\n    if not self._private_key or not self._key_type:\n        raise DidException(\"Private key is required to register new DID\")\n\n    if self.identifier:\n        document = await self.resolve()\n        if document.controller:\n            raise DidException(\"DID is already registered\")\n    else:\n        topic_options = HcsTopicOptions(\n            admin_key=self._private_key.public_key(), submit_key=self._private_key.public_key()\n        )\n\n        self.topic_id = await self._hcs_topic_service.create_topic(topic_options, [self._private_key])\n\n        self.network = self._client.network.network\n        self.identifier = build_identifier(\n            self.network,\n            multibase_encode(bytes(self._private_key.public_key().to_bytes_raw()), \"base58btc\"),\n            self.topic_id,\n        )\n\n    hcs_event = HcsDidUpdateDidOwnerEvent(\n        id_=self.identifier,\n        controller=self.identifier,\n        public_key=self._private_key.public_key(),\n        type_=self._key_type,\n    )\n\n    await self._submit_transaction(DidDocumentOperation.CREATE, hcs_event)\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did.HederaDid.resolve","title":"<code>resolve()</code>  <code>async</code>","text":"<p>Resolve DID document for registered instance.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>DidDocument</code> <p>DID document</p> Source code in <code>hiero_did_sdk_python/did/hedera_did.py</code> <pre><code>async def resolve(self) -&gt; DidDocument:\n    \"\"\"\n    Resolve DID document for registered instance.\n\n    Returns:\n        object: DID document\n    \"\"\"\n    if not self.topic_id or not self.identifier:\n        raise DidException(\"DID is not registered\")\n\n    result = await HcsMessageResolver(self.topic_id, HcsDidMessageEnvelope).execute(self._client)\n    await self._handle_resolution_result(cast(list[HcsDidMessageEnvelope], result))\n\n    return cast(DidDocument, self.document)\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did.HederaDid.revoke_service","title":"<code>revoke_service(id_)</code>  <code>async</code>","text":"<p>Revoke existing DID document service</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Service ID to revoke</p> required Source code in <code>hiero_did_sdk_python/did/hedera_did.py</code> <pre><code>async def revoke_service(self, id_: str):\n    \"\"\"Revoke existing DID document service\n\n    Args:\n        id_: Service ID to revoke\n    \"\"\"\n    self._assert_can_submit_transaction()\n\n    hcs_event = HcsDidRevokeServiceEvent(id_)\n    await self._submit_transaction(DidDocumentOperation.REVOKE, hcs_event)\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did.HederaDid.revoke_verification_method","title":"<code>revoke_verification_method(id_)</code>  <code>async</code>","text":"<p>Revoke existing DID document verification method</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Verification method ID to revoke</p> required Source code in <code>hiero_did_sdk_python/did/hedera_did.py</code> <pre><code>async def revoke_verification_method(self, id_: str):\n    \"\"\"Revoke existing DID document verification method\n\n    Args:\n        id_: Verification method ID to revoke\n    \"\"\"\n    self._assert_can_submit_transaction()\n\n    hcs_event = HcsDidRevokeVerificationMethodEvent(id_)\n    await self._submit_transaction(DidDocumentOperation.REVOKE, hcs_event)\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.hedera_did.HederaDid.revoke_verification_relationship","title":"<code>revoke_verification_relationship(id_, relationship_type)</code>  <code>async</code>","text":"<p>Revoke existing DID document verification relationship</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>Verification relationship ID to revoke</p> required <code>relationship_type</code> <code>VerificationRelationshipType</code> <p>Verification relationship type</p> required Source code in <code>hiero_did_sdk_python/did/hedera_did.py</code> <pre><code>async def revoke_verification_relationship(self, id_: str, relationship_type: VerificationRelationshipType):\n    \"\"\"Revoke existing DID document verification relationship\n\n    Args:\n        id_: Verification relationship ID to revoke\n        relationship_type: Verification relationship type\n    \"\"\"\n    self._assert_can_submit_transaction()\n\n    hcs_event = HcsDidRevokeVerificationRelationshipEvent(id_, relationship_type)\n    await self._submit_transaction(DidDocumentOperation.REVOKE, hcs_event)\n</code></pre>"},{"location":"modules/did/#models-and-types","title":"Models and types","text":""},{"location":"modules/did/#hiero_did_sdk_python.did.did_document.DidDocument","title":"<code>DidDocument</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>DID document representation</p> <p>Attributes:</p> Name Type Description <code>created</code> <code>datetime | None</code> <p>Creation timestamp</p> <code>updated</code> <code>datetime | None</code> <p>Last update timestamp</p> <code>deactivated</code> <code>bool</code> <p>DID document deactivation status</p> <code>controller</code> <code>dict | None</code> <p>Dictionary representing DID document controller info</p> <code>services</code> <code>dict</code> <p>DID document services dictionary</p> <code>verification_methods</code> <code>dict</code> <p>DID document verification methods dictionary</p> <code>verification_methods</code> <code>dict</code> <p>DID document verification relationships dictionary</p> Source code in <code>hiero_did_sdk_python/did/did_document.py</code> <pre><code>class DidDocument(Serializable):\n    \"\"\"DID document representation\n\n    Attributes:\n        created: Creation timestamp\n        updated: Last update timestamp\n        deactivated: DID document deactivation status\n        controller: Dictionary representing DID document controller info\n        services: DID document services dictionary\n        verification_methods: DID document verification methods dictionary\n        verification_methods: DID document verification relationships dictionary\n\n    \"\"\"\n\n    def __init__(self, id_: str):\n        self.id_ = id_\n        self.context = DID_DOCUMENT_CONTEXT\n\n        self.created: datetime | None = None\n        self.updated: datetime | None = None\n        self.deactivated: bool = False\n\n        self.controller: dict | None = None\n        self.services: dict = {}\n        self.verification_methods: dict = {}\n\n        self.verification_relationships: dict = {\n            DidDocumentJsonProperties.AUTHENTICATION.value: [],\n            DidDocumentJsonProperties.ASSERTION_METHOD.value: [],\n            DidDocumentJsonProperties.KEY_AGREEMENT.value: [],\n            DidDocumentJsonProperties.CAPABILITY_INVOCATION.value: [],\n            DidDocumentJsonProperties.CAPABILITY_DELEGATION.value: [],\n        }\n\n        self._public_key: PublicKey | None = None\n\n    @property\n    def version_timestamp(self) -&gt; datetime | None:\n        return self.updated or self.created\n\n    async def process_messages(self, envelopes: list[HcsDidMessageEnvelope]):\n        \"\"\"\n        Process HCS DID messages - apply DID document state changes according to events.\n\n        Args:\n            envelopes: HCS DID message envelopes (message + signature) to process\n\n        \"\"\"\n        for envelope in envelopes:\n            message = cast(HcsDidMessage, envelope.message)\n\n            if not self.controller:\n                event_target = message.event.event_target\n                if event_target != HcsDidEventTarget.DID_OWNER and event_target != HcsDidEventTarget.DID_DOCUMENT:\n                    LOGGER.warning(\"DID document is not registered, skipping DID event...\")\n                    continue\n\n            # TODO: Find a good way to support CID-based DID Document creation without workarounds and redundancy\n            # It's possible that we want to drop support for this case instead\n            is_signature_valid = (\n                message.event.event_target == HcsDidEventTarget.DID_DOCUMENT\n                or self._is_message_signature_valid(message, cast(str, envelope.signature))\n            )\n\n            if not is_signature_valid:\n                LOGGER.warning(\"HCS DID message signature is invalid, skipping event...\")\n                continue\n\n            match message.operation:\n                case DidDocumentOperation.CREATE:\n                    await self._process_create_message(message)\n                case DidDocumentOperation.UPDATE:\n                    self._process_update_message(message)\n                case DidDocumentOperation.DELETE:\n                    self._process_delete_message(message)\n                case DidDocumentOperation.REVOKE:\n                    self._process_revoke_message(message)\n                case _:\n                    LOGGER.warning(f\"Operation {message.operation} is not supported, skipping DID event...\")\n\n    @classmethod\n    def from_json_payload(cls, payload: dict):\n        raise Exception(\"DidDocument deserialization is not implemented\")\n\n    def get_json_payload(self):\n        root_object: dict = {\n            DidDocumentJsonProperties.CONTEXT.value: self.context,\n            DidDocumentJsonProperties.ID.value: self.id_,\n        }\n\n        if self.controller and self.id_ != self.controller.get(\"controller\"):\n            root_object[DidDocumentJsonProperties.CONTROLLER.value] = (\n                self.controller.get(\"controller\") or self.controller\n            )\n\n        root_object[DidDocumentJsonProperties.VERIFICATION_METHOD.value] = list(self.verification_methods.values())\n\n        root_object[DidDocumentJsonProperties.ASSERTION_METHOD.value] = [\n            *self.verification_relationships[DidDocumentJsonProperties.ASSERTION_METHOD.value],\n        ]\n\n        root_object[DidDocumentJsonProperties.AUTHENTICATION.value] = [\n            *self.verification_relationships[DidDocumentJsonProperties.AUTHENTICATION.value],\n        ]\n\n        if self.controller:\n            controller_id = self.controller.get(\"id\")\n\n            root_object[DidDocumentJsonProperties.VERIFICATION_METHOD.value].insert(0, self.controller)\n            root_object[DidDocumentJsonProperties.ASSERTION_METHOD.value].insert(0, controller_id)\n            root_object[DidDocumentJsonProperties.AUTHENTICATION.value].insert(0, controller_id)\n\n        if len(self.verification_relationships[DidDocumentJsonProperties.KEY_AGREEMENT.value]) &gt; 0:\n            root_object[DidDocumentJsonProperties.KEY_AGREEMENT.value] = [\n                *self.verification_relationships[DidDocumentJsonProperties.KEY_AGREEMENT.value],\n            ]\n        if len(self.verification_relationships[DidDocumentJsonProperties.CAPABILITY_INVOCATION.value]) &gt; 0:\n            root_object[DidDocumentJsonProperties.CAPABILITY_INVOCATION.value] = [\n                *self.verification_relationships[DidDocumentJsonProperties.CAPABILITY_INVOCATION.value],\n            ]\n        if len(self.verification_relationships[DidDocumentJsonProperties.CAPABILITY_DELEGATION.value]) &gt; 0:\n            root_object[DidDocumentJsonProperties.CAPABILITY_DELEGATION.value] = [\n                *self.verification_relationships[DidDocumentJsonProperties.CAPABILITY_DELEGATION.value],\n            ]\n\n        if len(self.services) &gt; 0:\n            root_object[DidDocumentJsonProperties.SERVICE.value] = list(self.services.values())\n\n        return root_object\n\n    async def _process_create_message(self, message: HcsDidMessage):\n        event = message.event\n\n        match event.event_target:\n            case HcsDidEventTarget.DID_DOCUMENT:\n                document = await download_ipfs_document_by_cid(cast(HcsDidCreateDidDocumentEvent, event).cid)\n\n                if document[DidDocumentJsonProperties.ID] != self.id_:\n                    raise ValueError(\"Document ID does not match did\")\n\n                self.controller = document[DidDocumentJsonProperties.CONTROLLER]\n\n                self.services = {\n                    service[\"id\"]: service for service in document.get(DidDocumentJsonProperties.SERVICE, [])\n                }\n\n                self.verification_methods = {\n                    verificationMethod[\"id\"]: verificationMethod\n                    for verificationMethod in document.get(DidDocumentJsonProperties.VERIFICATION_METHOD, [])\n                }\n\n                root_verification_method = next(\n                    filter(\n                        lambda verification_method: \"#did-root-key\" in verification_method[\"id\"],\n                        self.verification_methods.values(),\n                    )\n                )\n                self._public_key = PublicKey.from_bytes(b58_to_bytes(root_verification_method[\"publicKeyBase58\"]))\n\n                self.verification_relationships[DidDocumentJsonProperties.ASSERTION_METHOD] = document.get(\n                    DidDocumentJsonProperties.ASSERTION_METHOD, []\n                )\n                self.verification_relationships[DidDocumentJsonProperties.AUTHENTICATION] = document.get(\n                    DidDocumentJsonProperties.AUTHENTICATION, []\n                )\n                self.verification_relationships[DidDocumentJsonProperties.KEY_AGREEMENT] = document.get(\n                    DidDocumentJsonProperties.KEY_AGREEMENT, []\n                )\n                self.verification_relationships[DidDocumentJsonProperties.CAPABILITY_INVOCATION] = document.get(\n                    DidDocumentJsonProperties.CAPABILITY_INVOCATION, []\n                )\n                self.verification_relationships[DidDocumentJsonProperties.CAPABILITY_DELEGATION] = document.get(\n                    DidDocumentJsonProperties.CAPABILITY_DELEGATION, []\n                )\n            case HcsDidEventTarget.DID_OWNER:\n                if self.controller:\n                    LOGGER.warning(f\"DID owner is already registered: {self.controller}, skipping event...\")\n                    return\n\n                did_owner_event = cast(HcsDidUpdateDidOwnerEvent, event)\n\n                self.controller = did_owner_event.get_controller_verification_method()\n                self._public_key = did_owner_event.public_key\n                self._on_activated(message.timestamp)\n            case _:\n                LOGGER.warning(f\"Create {event.event_target} operation is not supported, skipping event...\")\n\n    def _process_update_message(self, message: HcsDidMessage):\n        event = message.event\n\n        match event.event_target:\n            case HcsDidEventTarget.DID_OWNER:\n                did_owner_event = cast(HcsDidUpdateDidOwnerEvent, event)\n\n                self.controller = did_owner_event.get_controller_verification_method()\n                self._public_key = did_owner_event.public_key\n                self._on_updated(message.timestamp)\n            case HcsDidEventTarget.SERVICE:\n                update_service_event = cast(HcsDidUpdateServiceEvent, event)\n                event_id = update_service_event.id_\n\n                self.services[event_id] = update_service_event.get_service_def()\n                self._on_updated(message.timestamp)\n            case HcsDidEventTarget.VERIFICATION_METHOD:\n                update_verification_method_event = cast(HcsDidUpdateVerificationMethodEvent, event)\n                event_id = update_verification_method_event.id_\n\n                self.verification_methods[event_id] = update_verification_method_event.get_verification_method_def()\n                self._on_updated(message.timestamp)\n            case HcsDidEventTarget.VERIFICATION_RELATIONSHIP:\n                update_verification_relationship_event = cast(HcsDidUpdateVerificationRelationshipEvent, event)\n                relationship_type = update_verification_relationship_event.relationship_type\n                event_id = update_verification_relationship_event.id_\n\n                if relationship_type not in self.verification_relationships:\n                    LOGGER.warning(\n                        f\"Update Verification Relationship event with type {relationship_type} is not supported, skipping event...\"\n                    )\n                    return\n\n                if event_id not in self.verification_relationships[relationship_type]:\n                    self.verification_relationships[relationship_type].append(event_id)\n\n                self.verification_methods[event_id] = (\n                    update_verification_relationship_event.get_verification_method_def()\n                )\n                self._on_updated(message.timestamp)\n            case _:\n                LOGGER.warning(f\"Update {event.event_target} operation is not supported, skipping event...\")\n\n    def _process_revoke_message(self, message: HcsDidMessage):\n        event = message.event\n\n        match event.event_target:\n            case HcsDidEventTarget.SERVICE:\n                revoke_service_event = cast(HcsDidRevokeServiceEvent, event)\n                event_id = revoke_service_event.id_\n\n                if event_id not in self.services:\n                    LOGGER.warning(f\"Service with ID: {event_id} is not found on the document, skipping event...\")\n                    return\n\n                del self.services[event_id]\n                self._on_updated(message.timestamp)\n            case HcsDidEventTarget.VERIFICATION_METHOD:\n                revoke_verification_method_event = cast(HcsDidRevokeVerificationMethodEvent, event)\n                event_id = revoke_verification_method_event.id_\n\n                if event_id not in self.verification_methods:\n                    LOGGER.warning(\n                        f\"Verification Method with ID: {event_id} is not found on the document, skipping event...\"\n                    )\n                    return\n\n                del self.verification_methods[event_id]\n\n                for type_key in self.verification_relationships:\n                    self.verification_relationships[type_key] = list(\n                        filter(lambda id_: id_ != event_id, self.verification_relationships[type_key])\n                    )\n\n                self._on_updated(message.timestamp)\n            case HcsDidEventTarget.VERIFICATION_RELATIONSHIP:\n                revoke_verification_relationship_event = cast(HcsDidUpdateVerificationRelationshipEvent, event)\n                relationship_type = revoke_verification_relationship_event.relationship_type\n                event_id = revoke_verification_relationship_event.id_\n\n                if relationship_type not in self.verification_relationships:\n                    LOGGER.warning(\n                        f\"Revoke verification Relationship event with type {relationship_type} is not supported, skipping event...\"\n                    )\n                    return\n\n                if event_id not in self.verification_relationships[relationship_type]:\n                    LOGGER.warning(\n                        f\"Verification Relationship with ID: {event_id} is not found on the document, skipping event...\"\n                    )\n                    return\n\n                self.verification_relationships[relationship_type] = list(\n                    filter(lambda id_: id_ != event_id, self.verification_relationships[relationship_type])\n                )\n\n                can_delete_verification_method = all(\n                    event_id not in rel for rel in self.verification_relationships.values()\n                )\n\n                if can_delete_verification_method:\n                    del self.verification_methods[event_id]\n\n                self._on_updated(message.timestamp)\n            case _:\n                LOGGER.warning(f\"Revoke {event.event_target} operation is not supported, skipping event...\")\n\n    def _process_delete_message(self, message: HcsDidMessage):\n        event = message.event\n\n        match event.event_target:\n            case HcsDidEventTarget.DOCUMENT:\n                self.controller = None\n                self.services.clear()\n                self.verification_methods.clear()\n                for type_key in self.verification_relationships:\n                    self.verification_relationships[type_key] = []\n                self._on_deactivated()\n            case _:\n                LOGGER.warning(f\"Delete {event.event_target} operation is not supported, skipping event...\")\n\n    def _is_message_signature_valid(self, message: HcsDidMessage, signature: str) -&gt; bool:\n        is_create_or_update_event = (\n            message.operation == DidDocumentOperation.CREATE or message.operation == DidDocumentOperation.UPDATE\n        )\n        is_did_owner_change_event = (\n            is_create_or_update_event and message.event.event_target == HcsDidEventTarget.DID_OWNER\n        )\n\n        public_key = (\n            cast(HcsDidUpdateDidOwnerEvent, message.event).public_key if is_did_owner_change_event else self._public_key\n        )\n\n        if not public_key:\n            raise Exception(\"Cannot verify HCS DID Message signature - controller public key is not defined\")\n\n        message_bytes = message.to_json().encode()\n        signature_bytes = b64_to_bytes(signature)\n\n        try:\n            public_key.verify(signature_bytes, message_bytes)\n        except Exception as error:\n            LOGGER.warning(f\"HCS DID Message signature verification failed with error: {error!s}\")\n            return False\n\n        return True\n\n    def _on_activated(self, timestamp: datetime):\n        self.created = timestamp\n        self.updated = timestamp\n        self.deactivated = False\n\n    def _on_updated(self, timestamp: datetime):\n        self.updated = timestamp\n\n    def _on_deactivated(self):\n        self.created = None\n        self.updated = None\n        self.deactivated = True\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.did_document.DidDocument.process_messages","title":"<code>process_messages(envelopes)</code>  <code>async</code>","text":"<p>Process HCS DID messages - apply DID document state changes according to events.</p> <p>Parameters:</p> Name Type Description Default <code>envelopes</code> <code>list[HcsDidMessageEnvelope]</code> <p>HCS DID message envelopes (message + signature) to process</p> required Source code in <code>hiero_did_sdk_python/did/did_document.py</code> <pre><code>async def process_messages(self, envelopes: list[HcsDidMessageEnvelope]):\n    \"\"\"\n    Process HCS DID messages - apply DID document state changes according to events.\n\n    Args:\n        envelopes: HCS DID message envelopes (message + signature) to process\n\n    \"\"\"\n    for envelope in envelopes:\n        message = cast(HcsDidMessage, envelope.message)\n\n        if not self.controller:\n            event_target = message.event.event_target\n            if event_target != HcsDidEventTarget.DID_OWNER and event_target != HcsDidEventTarget.DID_DOCUMENT:\n                LOGGER.warning(\"DID document is not registered, skipping DID event...\")\n                continue\n\n        # TODO: Find a good way to support CID-based DID Document creation without workarounds and redundancy\n        # It's possible that we want to drop support for this case instead\n        is_signature_valid = (\n            message.event.event_target == HcsDidEventTarget.DID_DOCUMENT\n            or self._is_message_signature_valid(message, cast(str, envelope.signature))\n        )\n\n        if not is_signature_valid:\n            LOGGER.warning(\"HCS DID message signature is invalid, skipping event...\")\n            continue\n\n        match message.operation:\n            case DidDocumentOperation.CREATE:\n                await self._process_create_message(message)\n            case DidDocumentOperation.UPDATE:\n                self._process_update_message(message)\n            case DidDocumentOperation.DELETE:\n                self._process_delete_message(message)\n            case DidDocumentOperation.REVOKE:\n                self._process_revoke_message(message)\n            case _:\n                LOGGER.warning(f\"Operation {message.operation} is not supported, skipping DID event...\")\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.did_error.DidErrorCode","title":"<code>DidErrorCode</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum for DID-related error codes</p> Source code in <code>hiero_did_sdk_python/did/did_error.py</code> <pre><code>class DidErrorCode(StrEnum):\n    \"\"\"Enum for DID-related error codes\"\"\"\n\n    \"\"\"Generic (unknown) error\"\"\"\n    GENERIC = \"generic\"\n\n    \"\"\"Invalid DID identifier string. Can be caused by non-Hedera DID method prefix, invalid or missing Topic ID and generally incorrect format\"\"\"\n    INVALID_DID_STRING = \"invalid_did_string\"\n\n    \"\"\"Invalid Hedera network specified in DID identifier\"\"\"\n    INVALID_NETWORK = \"invalid_network\"\n\n    \"\"\"Specified DID is not found\"\"\"\n    DID_NOT_FOUND = \"did_not_found\"\n</code></pre>"},{"location":"modules/did/#hiero_did_sdk_python.did.did_error.DidErrorCode.GENERIC","title":"<code>GENERIC = 'generic'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Invalid DID identifier string. Can be caused by non-Hedera DID method prefix, invalid or missing Topic ID and generally incorrect format</p>"},{"location":"modules/did/#hiero_did_sdk_python.did.did_error.DidErrorCode.INVALID_DID_STRING","title":"<code>INVALID_DID_STRING = 'invalid_did_string'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Invalid Hedera network specified in DID identifier</p>"},{"location":"modules/did/#hiero_did_sdk_python.did.did_error.DidErrorCode.INVALID_NETWORK","title":"<code>INVALID_NETWORK = 'invalid_network'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Specified DID is not found</p>"},{"location":"modules/did/#hiero_did_sdk_python.did.did_error.DidException","title":"<code>DidException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Class for DID-related exceptions</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message</p> required <code>code</code> <code>DidErrorCode</code> <p>DID Error code</p> <code>GENERIC</code> Source code in <code>hiero_did_sdk_python/did/did_error.py</code> <pre><code>class DidException(Exception):\n    \"\"\"Class for DID-related exceptions\n\n    Args:\n        message: Error message\n        code: DID Error code\n    \"\"\"\n\n    def __init__(self, message: str, code: DidErrorCode = DidErrorCode.GENERIC):\n        super().__init__(message)\n\n        self.code = code\n</code></pre>"}]}